| **Question**                                                         | **Answer**                                                                                                                                                                                                                                                                                                                                                 |
|---------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **1. Two Sum**                                                       | **Solution:** <br> ```java <br> public int[] twoSum(int[] nums, int target) { <br>     HashMap<Integer, Integer> map = new HashMap<>(); <br>     for (int i = 0; i < nums.length; i++) { <br>         int complement = target - nums[i]; <br>         if (map.containsKey(complement)) { <br>             return new int[]{map.get(complement), i}; <br>         } <br>         map.put(nums[i], i); <br>     } <br>     throw new IllegalArgumentException("No solution found"); <br> } </br>``` |
| **2. Add Two Numbers**                                               | **Solution:** <br> ```java <br> public ListNode addTwoNumbers(ListNode l1, ListNode l2) { <br>     ListNode dummy = new ListNode(0); <br>     ListNode p = l1, q = l2, current = dummy; <br>     int carry = 0; <br>     while (p != null || q != null || carry != 0) { <br>         int x = (p != null) ? p.val : 0; <br>         int y = (q != null) ? q.val : 0; <br>         int sum = x + y + carry; <br>         carry = sum / 10; <br>         current.next = new ListNode(sum % 10); <br>         current = current.next; <br>         if (p != null) p = p.next; <br>         if (q != null) q = q.next; <br>     } <br>     return dummy.next; <br> } </br> ```                                                                                                                                                         |
| **3. Longest Substring Without Repeating Characters**                | **Solution:** <br> ```java <br> public int lengthOfLongestSubstring(String s) { <br>     Set<Character> set = new HashSet<>(); <br>     int left = 0, maxLength = 0; <br>     for (int right = 0; right < s.length(); right++) { <br>         while (set.contains(s.charAt(right))) { <br>             set.remove(s.charAt(left)); <br>             left++; <br>         } <br>         set.add(s.charAt(right)); <br>         maxLength = Math.max(maxLength, right - left + 1); <br>     } <br>     return maxLength; <br> } </br> ```                                                                                                                                          |
| **4. Median of Two Sorted Arrays**                                   | **Solution:** <br> ```java <br> public double findMedianSortedArrays(int[] nums1, int[] nums2) { <br>     int m = nums1.length, n = nums2.length; <br>     if (m > n) return findMedianSortedArrays(nums2, nums1); <br>     int left = 0, right = m, mid = (m + n + 1) / 2; <br>     while (left < right) { <br>         int i = left + (right - left) / 2; <br>         int j = mid - i; <br>         if (nums1[i] < nums2[j - 1]) { <br>             left = i + 1; <br>         } <br>         else { <br>             right = i; <br>         } <br>     } <br>     int i = left, j = mid - i; <br>     int maxLeft = Math.max(i > 0 ? nums1[i - 1] : Integer.MIN_VALUE, j > 0 ? nums2[j - 1] : Integer.MIN_VALUE); <br>     if ((m + n) % 2 == 1) return maxLeft; <br>     int minRight = Math.min(i < m ? nums1[i] : Integer.MAX_VALUE, j < n ? nums2[j] : Integer.MAX_VALUE); <br>     return (maxLeft + minRight) / 2.0; <br> } </br> ```                                                                                             |
| **5. Longest Palindromic Substring**                                  | **Solution:** <br> ```java <br> public String longestPalindrome(String s) { <br>     if (s == null || s.length() < 1) return ""; <br>     int start = 0, end = 0; <br>     for (int i = 0; i < s.length(); i++) { <br>         int len1 = expandAroundCenter(s, i, i); <br>         int len2 = expandAroundCenter(s, i, i + 1); <br>         int len = Math.max(len1, len2); <br>         if (len > end - start) { <br>             start = i - (len - 1) / 2; <br>             end = i + len / 2; <br>         } <br>     } <br>     return s.substring(start, end + 1); <br> } <br> private int expandAroundCenter(String s, int left, int right) { <br>     while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) { <br>         left--; <br>         right++; <br>     } <br>     return right - left - 1; <br> } </br> ```                                                                                                                                |
| **6. Zigzag Conversion**                                               | **Solution:** <br> ```java <br> public String convert(String s, int numRows) { <br>     if (numRows == 1) return s; <br>     StringBuilder result = new StringBuilder(); <br>     int cycleLength = 2 * numRows - 2; <br>     for (int row = 0; row < numRows; row++) { <br>         for (int i = row; i < s.length(); i += cycleLength) { <br>             result.append(s.charAt(i)); <br>             int mid = i + cycleLength - 2 * row; <br>             if (row != 0 && row != numRows - 1 && mid < s.length()) { <br>                 result.append(s.charAt(mid)); <br>             } <br>         } <br>     } <br>     return result.toString(); <br> } </br> ```                                                                                                                                                 |
| **7. Reverse Integer**                                                 | **Solution:** <br> ```java <br> public int reverse(int x) { <br>     int result = 0; <br>     while (x != 0) { <br>         int digit = x % 10; <br>         x /= 10; <br>         if (result > Integer.MAX_VALUE / 10 || (result == Integer.MAX_VALUE / 10 && digit > 7)) return 0; <br>         if (result < Integer.MIN_VALUE / 10 || (result == Integer.MIN_VALUE / 10 && digit < -8)) return 0; <br>         result = result * 10 + digit; <br>     } <br>     return result; <br> } </br> ```                                                                                                                                                                                                                           |
| **8. String to Integer (atoi)**                                         | **Solution:** <br> ```java <br> public int myAtoi(String s) { <br>     int i = 0, sign = 1, result = 0; <br>     s = s.trim(); <br>     if (i < s.length() && (s.charAt(i) == '-' || s.charAt(i) == '+')) { <br>         sign = s.charAt(i++) == '-' ? -1 : 1; <br>     } <br>     while (i < s.length() && Character.isDigit(s.charAt(i))) { <br>         int digit = s.charAt(i++) - '0'; <br>         if (result > Integer.MAX_VALUE / 10 || (result == Integer.MAX_VALUE / 10 && digit > 7)) return Integer.MAX_VALUE; <br>         if (result < Integer.MIN_VALUE / 10 || (result == Integer.MIN_VALUE / 10 && digit < -8)) return Integer.MIN_VALUE; <br>         result = result * 10 + sign * digit; <br>     } <br>     return result; <br> } </br> ```                                                                                                                                                                       |
| **9. Palindrome Number**                                                | **Solution:** <br> ```java <br> public boolean isPalindrome(int x) { <br>     if (x < 0) return false; <br>     int original = x, reversed = 0; <br>     while (x != 0) { <br>         reversed = reversed * 10 + x % 10; <br>         x /= 10; <br>     } <br>     return original == reversed; <br> } </br> ```                                                                                                                                                                      |
| **10. Regular Expression Matching**                                     | **Solution:** <br> ```java <br> public boolean isMatch(String s, String p) { <br>     boolean[][] dp = new boolean[s.length() + 1][p.length() + 1]; <br>     dp[0][0] = true; <br>     for (int j = 1; j <= p.length(); j++) { <br>         if (p.charAt(j - 1) == '*') { <br>             dp[0][j] = dp[0][j - 2]; <br>         } <br>     } <br>     for (int i = 1; i <= s.length(); i++) { <br>         for (int j = 1; j <= p.length(); j++) { <br>             if (p.charAt(j - 1) == s.charAt(i - 1) || p.charAt(j - 1) == '.') { <br>                 dp[i][j] = dp[i - 1][j - 1]; <br>             } <br>             if (p.charAt(j - 1) == '*') { <br>                 dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.')); <br>             } <br>         } <br>     } <br>     return dp[s.length()][p.length()]; <br> } </br> ```                                                                                                                                                       |
| **11. Container With Most Water**                                       | **Solution:** <br> ```java <br> public int maxArea(int[] height) { <br>     int left = 0, right = height.length - 1, maxArea = 0; <br>     while (left < right) { <br>         int area = (right - left) * Math.min(height[left], height[right]); <br>         maxArea = Math.max(maxArea, area); <br>         if (height[left] < height[right]) left++; <br>         else right--; <br>     } <br>     return maxArea; <br> } </br> ```                                                                                                                                                       |
| **Question**                                                          | **Answer**                                                                                                                                                                                                                                                                                                                                                         |
|----------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **12. Integer to Roman**                                              | **Solution:** <br> ```java <br> public String intToRoman(int num) { <br>     String[] thousands = {"", "M", "MM", "MMM"}; <br>     String[] hundreds = {"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"}; <br>     String[] tens = {"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"}; <br>     String[] ones = {"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"}; <br>     return thousands[num / 1000] + hundreds[(num % 1000) / 100] + tens[(num % 100) / 10] + ones[num % 10]; <br> } </br> ```                                                                                           |
| **13. Roman to Integer**                                              | **Solution:** <br> ```java <br> public int romanToInt(String s) { <br>     Map<Character, Integer> map = new HashMap<>(); <br>     map.put('I', 1); <br>     map.put('V', 5); <br>     map.put('X', 10); <br>     map.put('L', 50); <br>     map.put('C', 100); <br>     map.put('D', 500); <br>     map.put('M', 1000); <br>     int result = 0; <br>     for (int i = 0; i < s.length(); i++) { <br>         if (i < s.length() - 1 && map.get(s.charAt(i)) < map.get(s.charAt(i + 1))) { <br>             result -= map.get(s.charAt(i)); <br>         } else { <br>             result += map.get(s.charAt(i)); <br>         } <br>     } <br>     return result; <br> } </br> ```                                                                                     |
| **14. Longest Common Prefix**                                          | **Solution:** <br> ```java <br> public String longestCommonPrefix(String[] strs) { <br>     if (strs == null || strs.length == 0) return ""; <br>     String prefix = strs[0]; <br>     for (int i = 1; i < strs.length; i++) { <br>         while (strs[i].indexOf(prefix) != 0) { <br>             prefix = prefix.substring(0, prefix.length() - 1); <br>             if (prefix.isEmpty()) return ""; <br>         } <br>     } <br>     return prefix; <br> } </br> ```                                                                                                             |
| **15. 3Sum**                                                           | **Solution:** <br> ```java <br> public List<List<Integer>> threeSum(int[] nums) { <br>     List<List<Integer>> result = new ArrayList<>(); <br>     Arrays.sort(nums); <br>     for (int i = 0; i < nums.length - 2; i++) { <br>         if (i > 0 && nums[i] == nums[i - 1]) continue; <br>         int left = i + 1, right = nums.length - 1; <br>         while (left < right) { <br>             int sum = nums[i] + nums[left] + nums[right]; <br>             if (sum == 0) { <br>                 result.add(Arrays.asList(nums[i], nums[left], nums[right])); <br>                 while (left < right && nums[left] == nums[left + 1]) left++; <br>                 while (left < right && nums[right] == nums[right - 1]) right--; <br>                 left++; <br>                 right--; <br>             } else if (sum < 0) { <br>                 left++; <br>             } else { <br>                 right--; <br>             } <br>         } <br>     } <br>     return result; <br> } </br> ```                                                                                                                                 |
| **16. 3Sum Closest**                                                   | **Solution:** <br> ```java <br> public int threeSumClosest(int[] nums, int target) { <br>     Arrays.sort(nums); <br>     int closest = Integer.MAX_VALUE; <br>     for (int i = 0; i < nums.length - 2; i++) { <br>         int left = i + 1, right = nums.length - 1; <br>         while (left < right) { <br>             int sum = nums[i] + nums[left] + nums[right]; <br>             if (Math.abs(target - sum) < Math.abs(target - closest)) { <br>                 closest = sum; <br>             } <br>             if (sum < target) left++; <br>             else if (sum > target) right--; <br>             else return sum; <br>         } <br>     } <br>     return closest; <br> } </br> ```                                                                 |
| **17. Letter Combinations of a Phone Number**                          | **Solution:** <br> ```java <br> public List<String> letterCombinations(String digits) { <br>     List<String> result = new ArrayList<>(); <br>     if (digits == null || digits.length() == 0) return result; <br>     String[] mapping = {"0", "1", "ABC", "DEF", "GHI", "JKL", "MNO", "PQRS", "TUV", "WXYZ"}; <br>     backtrack(result, new StringBuilder(), digits, 0, mapping); <br>     return result; <br> } <br> private void backtrack(List<String> result, StringBuilder combination, String digits, int index, String[] mapping) { <br>     if (index == digits.length()) { <br>         result.add(combination.toString()); <br>         return; <br>     } <br>     String letters = mapping[digits.charAt(index) - '0']; <br>     for (int i = 0; i < letters.length(); i++) { <br>         combination.append(letters.charAt(i)); <br>         backtrack(result, combination, digits, index + 1, mapping); <br>         combination.deleteCharAt(combination.length() - 1); <br>     } <br> } </br> ```                                                                                                  |
| **18. 4Sum**                                                           | **Solution:** <br> ```java <br> public List<List<Integer>> fourSum(int[] nums, int target) { <br>     List<List<Integer>> result = new ArrayList<>(); <br>     Arrays.sort(nums); <br>     for (int i = 0; i < nums.length - 3; i++) { <br>         if (i > 0 && nums[i] == nums[i - 1]) continue; <br>         for (int j = i + 1; j < nums.length - 2; j++) { <br>             if (j > i + 1 && nums[j] == nums[j - 1]) continue; <br>             int left = j + 1, right = nums.length - 1; <br>             while (left < right) { <br>                 int sum = nums[i] + nums[j] + nums[left] + nums[right]; <br>                 if (sum == target) { <br>                     result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right])); <br>                     while (left < right && nums[left] == nums[left + 1]) left++; <br>                     while (left < right && nums[right] == nums[right - 1]) right--; <br>                     left++; <br>                     right--; <br>                 } else if (sum < target) { <br>                     left++; <br>                 } else { <br>                     right--; <br>                 } <br>             } <br>         } <br>     } <br>     return result; <br> } </br> ```                                                                                                                                                         |
| **19. Remove Nth Node From End of List**                               | **Solution:** <br> ```java <br> public ListNode removeNthFromEnd(ListNode head, int n) { <br>     ListNode dummy = new ListNode(0); <br>     dummy.next = head; <br>     ListNode fast = dummy, slow = dummy; <br>     for (int i = 1; i <= n + 1; i++) { <br>         fast = fast.next; <br>     } <br>     while (fast != null) { <br>         fast = fast.next; <br>         slow = slow.next; <br>     } <br>     slow.next = slow.next.next; <br>     return dummy.next; <br> } </br> ```                                                                                     |
| **20. Valid Parentheses**                                               | **Solution:** <br> ```java <br> public boolean isValid(String s) { <br>     Stack<Character> stack = new Stack<>(); <br>     for (char c : s.toCharArray()) { <br>         if (c == '(' || c == '{' || c == '[') { <br>             stack.push(c); <br>         } else { <br>             if (stack.isEmpty()) return false; <br>             char top = stack.pop(); <br>             if ((c == ')' && top != '(') || (c == '}' && top != '{') || (c == ']' && top != '[')) { <br>                 return false; <br>             } <br>         } <br>     } <br>     return stack.isEmpty(); <br> } </br> ```                                                                                                                                                       |
| **Question**                                                          | **Answer**                                                                                                                                                                                                                                                                                                                                                         |
|----------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **21. Merge Two Sorted Lists**                                         | **Solution:** <br> ```java <br> public ListNode mergeTwoLists(ListNode l1, ListNode l2) { <br>     if (l1 == null) return l2; <br>     if (l2 == null) return l1; <br>     if (l1.val < l2.val) { <br>         l1.next = mergeTwoLists(l1.next, l2); <br>         return l1; <br>     } else { <br>         l2.next = mergeTwoLists(l1, l2.next); <br>         return l2; <br>     } <br> } </br> ```                                                                                                  |
| **22. Generate Parentheses**                                            | **Solution:** <br> ```java <br> public List<String> generateParenthesis(int n) { <br>     List<String> result = new ArrayList<>(); <br>     backtrack(result, "", 0, 0, n); <br>     return result; <br> } <br> private void backtrack(List<String> result, String current, int open, int close, int n) { <br>     if (current.length() == 2 * n) { <br>         result.add(current); <br>         return; <br>     } <br>     if (open < n) backtrack(result, current + "(", open + 1, close, n); <br>     if (close < open) backtrack(result, current + ")", open, close + 1, n); <br> } </br> ```                                                                                                                                                               |
| **23. Merge k Sorted Lists**                                           | **Solution:** <br> ```java <br> public ListNode mergeKLists(ListNode[] lists) { <br>     if (lists == null || lists.length == 0) return null; <br>     return mergeHelper(lists, 0, lists.length - 1); <br> } <br> private ListNode mergeHelper(ListNode[] lists, int left, int right) { <br>     if (left == right) return lists[left]; <br>     int mid = (left + right) / 2; <br>     ListNode l1 = mergeHelper(lists, left, mid); <br>     ListNode l2 = mergeHelper(lists, mid + 1, right); <br>     return mergeTwoLists(l1, l2); <br> } <br> private ListNode mergeTwoLists(ListNode l1, ListNode l2) { <br>     ListNode dummy = new ListNode(0); <br>     ListNode current = dummy; <br>     while (l1 != null && l2 != null) { <br>         if (l1.val < l2.val) { <br>             current.next = l1; <br>             l1 = l1.next; <br>         } else { <br>             current.next = l2; <br>             l2 = l2.next; <br>         } <br>         current = current.next; <br>     } <br>     current.next = l1 != null ? l1 : l2; <br>     return dummy.next; <br> } </br> ```                                                                                                                                                                             |
| **24. Swap Nodes in Pairs**                                            | **Solution:** <br> ```java <br> public ListNode swapPairs(ListNode head) { <br>     if (head == null || head.next == null) return head; <br>     ListNode newHead = head.next; <br>     ListNode prev = null; <br>     ListNode curr = head; <br>     while (curr != null && curr.next != null) { <br>         ListNode next = curr.next.next; <br>         if (prev != null) prev.next = curr.next; <br>         curr.next.next = curr; <br>         curr.next = next; <br>         prev = curr; <br>         curr = next; <br>     } <br>     return newHead; <br> } </br> ```                                                                                      |
| **25. Reverse Nodes in k-Group**                                       | **Solution:** <br> ```java <br> public ListNode reverseKGroup(ListNode head, int k) { <br>     if (head == null || k == 1) return head; <br>     ListNode dummy = new ListNode(0); <br>     dummy.next = head; <br>     ListNode current = dummy, next = dummy, prev = dummy; <br>     int count = 0; <br>     while (next.next != null) { <br>         next = next.next; <br>         count++; <br>     } <br>     while (count >= k) { <br>         next = prev.next; <br>         current = next.next; <br>         for (int i = 1; i < k; i++) { <br>             next.next = current.next; <br>             current.next = prev.next; <br>             prev.next = current; <br>             current = next.next; <br>         } <br>         prev = next; <br>         count -= k; <br>     } <br>     return dummy.next; <br> } </br> ```                                                                                                                                                  |
| **26. Remove Duplicates from Sorted Array**                            | **Solution:** <br> ```java <br> public int removeDuplicates(int[] nums) { <br>     if (nums.length == 0) return 0; <br>     int i = 0; <br>     for (int j = 1; j < nums.length; j++) { <br>         if (nums[j] != nums[i]) { <br>             i++; <br>             nums[i] = nums[j]; <br>         } <br>     } <br>     return i + 1; <br> } </br> ```                                                                                                        |
| **27. Remove Element**                                                  | **Solution:** <br> ```java <br> public int removeElement(int[] nums, int val) { <br>     int i = 0; <br>     for (int j = 0; j < nums.length; j++) { <br>         if (nums[j] != val) { <br>             nums[i++] = nums[j]; <br>         } <br>     } <br>     return i; <br> } </br> ```                                                                                                      |
| **28. Implement strStr()**                                              | **Solution:** <br> ```java <br> public int strStr(String haystack, String needle) { <br>     if (needle == null || needle.length() == 0) return 0; <br>     if (haystack == null || haystack.length() < needle.length()) return -1; <br>     for (int i = 0; i <= haystack.length() - needle.length(); i++) { <br>         if (haystack.substring(i, i + needle.length()).equals(needle)) { <br>             return i; <br>         } <br>     } <br>     return -1; <br> } </br> ```                                                                                                               |
| **29. Divide Two Integers**                                             | **Solution:** <br> ```java <br> public int divide(int dividend, int divisor) { <br>     if (dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE; <br>     long dividendL = Math.abs((long) dividend); <br>     long divisorL = Math.abs((long) divisor); <br>     int result = 0; <br>     while (dividendL >= divisorL) { <br>         long tempDivisor = divisorL, multiple = 1; <br>         while (dividendL >= (tempDivisor << 1)) { <br>             tempDivisor <<= 1; <br>             multiple <<= 1; <br>         } <br>         dividendL -= tempDivisor; <br>         result += multiple; <br>     } <br>     return (dividend > 0) == (divisor > 0) ? result : -result; <br> } </br> ```                                                                                              |
| **30. Substring with Concatenation of All Words**                       | **Solution:** <br> ```java <br> public List<Integer> findSubstring(String s, String[] words) { <br>     List<Integer> result = new ArrayList<>(); <br>     if (words.length == 0 || s.length() == 0) return result; <br>     Map<String, Integer> wordCount = new HashMap<>(); <br>     for (String word : words) { <br>         wordCount.put(word, wordCount.getOrDefault(word, 0) + 1); <br>     } <br>     int wordLength = words[0].length(); <br>     int totalLength = wordLength * words.length; <br>     for (int i = 0; i <= s.length() - totalLength; i++) { <br>         Map<String, Integer> seen = new HashMap<>(); <br>         int j = 0; <br>         while (j < words.length) { <br>             String word = s.substring(i + j * wordLength, i + (j + 1) * wordLength); <br>             if (!wordCount.containsKey(word)) break; <br>             seen.put(word, seen.getOrDefault(word, 0) + 1); <br>             if (seen.get(word) > wordCount.get(word)) break; <br>             j++; <br>         } <br>         if (j == words.length) result.add(i); <br>     } <br>     return result; <br> } </br> ```                                                                                                            |
| **31. Next Permutation**                                                | **Solution:** <br> ```java <br> public void nextPermutation(int[] nums) { <br>     int i = nums.length - 2; <br>     while (i >= 0 && nums[i] >= nums[i + 1]) i--; <br>     if (i >= 0) { <br>         int j = nums.length - 1; <br>         while (nums[j] <= nums[i]) j--; <br>         swap(nums, i, j); <br>     } <br>     reverse(nums, i + 1); <br> } <br> private void swap(int[] nums, int i, int j) { <br>     int temp = nums[i]; <br>     nums[i] = nums[j]; <br>     nums[j] = temp; <br> } <br> private void reverse(int[] nums, int start) { <br>     int end = nums.length - 1; <br>     while (start < end) { <br>         swap(nums, start, end); <br>         start++; <br>         end--; <br>     } <br> } </br> ```                                                                                              |
| **Question**                                                          | **Answer**                                                                                                                                                                                                                                                                                                                                                         |
|----------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **32. Longest Valid Parentheses**                                      | **Solution:** <br> ```java <br> public int longestValidParentheses(String s) { <br>     Stack<Integer> stack = new Stack<>(); <br>     stack.push(-1); <br>     int maxLen = 0; <br>     for (int i = 0; i < s.length(); i++) { <br>         if (s.charAt(i) == '(') { <br>             stack.push(i); <br>         } else { <br>             stack.pop(); <br>             if (!stack.isEmpty()) { <br>                 maxLen = Math.max(maxLen, i - stack.peek()); <br>             } else { <br>                 stack.push(i); <br>             } <br>         } <br>     } <br>     return maxLen; <br> } </br> ```                                                                                                           |
| **33. Search in Rotated Sorted Array**                                 | **Solution:** <br> ```java <br> public int search(int[] nums, int target) { <br>     int left = 0, right = nums.length - 1; <br>     while (left <= right) { <br>         int mid = left + (right - left) / 2; <br>         if (nums[mid] == target) return mid; <br>         if (nums[left] <= nums[mid]) { <br>             if (nums[left] <= target && target < nums[mid]) right = mid - 1; <br>             else left = mid + 1; <br>         } else { <br>             if (nums[mid] < target && target <= nums[right]) left = mid + 1; <br>             else right = mid - 1; <br>         } <br>     } <br>     return -1; <br> } </br> ```                                                                                         |
| **34. Find First and Last Position of Element in Sorted Array**        | **Solution:** <br> ```java <br> public int[] searchRange(int[] nums, int target) { <br>     int[] result = new int[]{-1, -1}; <br>     if (nums == null || nums.length == 0) return result; <br>     result[0] = findBound(nums, target, true); <br>     result[1] = findBound(nums, target, false); <br>     return result; <br> } <br> private int findBound(int[] nums, int target, boolean isLeft) { <br>     int left = 0, right = nums.length - 1, bound = -1; <br>     while (left <= right) { <br>         int mid = left + (right - left) / 2; <br>         if (nums[mid] == target) { <br>             bound = mid; <br>             if (isLeft) right = mid - 1; <br>             else left = mid + 1; <br>         } else if (nums[mid] < target) left = mid + 1; <br>         else right = mid - 1; <br>     } <br>     return bound; <br> } </br> ```                                                                                          |
| **35. Search Insert Position**                                          | **Solution:** <br> ```java <br> public int searchInsert(int[] nums, int target) { <br>     int left = 0, right = nums.length; <br>     while (left < right) { <br>         int mid = left + (right - left) / 2; <br>         if (nums[mid] < target) { <br>             left = mid + 1; <br>         } else { <br>             right = mid; <br>         } <br>     } <br>     return left; <br> } </br> ```                                                                                          |
| **36. Valid Sudoku**                                                   | **Solution:** <br> ```java <br> public boolean isValidSudoku(char[][] board) { <br>     for (int i = 0; i < 9; i++) { <br>         Set<Character> rowSet = new HashSet<>(); <br>         Set<Character> colSet = new HashSet<>(); <br>         Set<Character> boxSet = new HashSet<>(); <br>         for (int j = 0; j < 9; j++) { <br>             if (board[i][j] != '.' && !rowSet.add(board[i][j])) return false; <br>             if (board[j][i] != '.' && !colSet.add(board[j][i])) return false; <br>             int rowIndex = 3 * (i / 3) + j / 3; <br>             int colIndex = 3 * (i % 3) + j % 3; <br>             if (board[rowIndex][colIndex] != '.' && !boxSet.add(board[rowIndex][colIndex])) return false; <br>         } <br>     } <br>     return true; <br> } </br> ```                                                                                                                |
| **37. Sudoku Solver**                                                  | **Solution:** <br> ```java <br> public void solveSudoku(char[][] board) { <br>     solve(board); <br> } <br> private boolean solve(char[][] board) { <br>     for (int i = 0; i < 9; i++) { <br>         for (int j = 0; j < 9; j++) { <br>             if (board[i][j] == '.') { <br>                 for (char c = '1'; c <= '9'; c++) { <br>                     if (isValid(board, i, j, c)) { <br>                         board[i][j] = c; <br>                         if (solve(board)) return true; <br>                         board[i][j] = '.'; <br>                     } <br>                 } <br>                 return false; <br>             } <br>         } <br>     } <br>     return true; <br> } <br> private boolean isValid(char[][] board, int row, int col, char c) { <br>     for (int i = 0; i < 9; i++) { <br>         if (board[row][i] == c || board[i][col] == c || board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) { <br>             return false; <br>         } <br>     } <br>     return true; <br> } </br> ```                                                                                                      |
| **38. Count and Say**                                                  | **Solution:** <br> ```java <br> public String countAndSay(int n) { <br>     if (n == 1) return "1"; <br>     String previous = "1"; <br>     for (int i = 2; i <= n; i++) { <br>         StringBuilder sb = new StringBuilder(); <br>         for (int j = 0; j < previous.length(); j++) { <br>             int count = 1; <br>             while (j + 1 < previous.length() && previous.charAt(j) == previous.charAt(j + 1)) { <br>                 count++; <br>                 j++; <br>             } <br>             sb.append(count).append(previous.charAt(j)); <br>         } <br>         previous = sb.toString(); <br>     } <br>     return previous; <br> } </br> ```                                                                                                         |
| **39. Combination Sum**                                                 | **Solution:** <br> ```java <br> public List<List<Integer>> combinationSum(int[] candidates, int target) { <br>     List<List<Integer>> result = new ArrayList<>(); <br>     backtrack(result, new ArrayList<>(), candidates, target, 0); <br>     return result; <br> } <br> private void backtrack(List<List<Integer>> result, List<Integer> temp, int[] candidates, int target, int start) { <br>     if (target < 0) return; <br>     if (target == 0) { <br>         result.add(new ArrayList<>(temp)); <br>         return; <br>     } <br>     for (int i = start; i < candidates.length; i++) { <br>         temp.add(candidates[i]); <br>         backtrack(result, temp, candidates, target - candidates[i], i); <br>         temp.remove(temp.size() - 1); <br>     } <br> } </br> ```                                                                                                         |
| **40. Combination Sum II**                                              | **Solution:** <br> ```java <br> public List<List<Integer>> combinationSum2(int[] candidates, int target) { <br>     List<List<Integer>> result = new ArrayList<>(); <br>     Arrays.sort(candidates); <br>     backtrack(result, new ArrayList<>(), candidates, target, 0); <br>     return result; <br> } <br> private void backtrack(List<List<Integer>> result, List<Integer> temp, int[] candidates, int target, int start) { <br>     if (target == 0) { <br>         result.add(new ArrayList<>(temp)); <br>         return; <br>     } <br>     for (int i = start; i < candidates.length; i++) { <br>         if (i > start && candidates[i] == candidates[i - 1]) continue; <br>         if (target < candidates[i]) break; <br>         temp.add(candidates[i]); <br>         backtrack(result, temp, candidates, target - candidates[i], i + 1); <br>         temp.remove(temp.size() - 1); <br>     } <br> } </br> ```                                                                                                                |
| **Question**                                                          | **Answer**                                                                                                                                                                                                                                                                                                                                                         |
|----------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **41. First Missing Positive**                                         | **Solution:** <br> ```java <br> public int firstMissingPositive(int[] nums) { <br>     int n = nums.length; <br>     for (int i = 0; i < n; i++) { <br>         while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) { <br>             int temp = nums[i]; <br>             nums[i] = nums[nums[i] - 1]; <br>             nums[temp - 1] = temp; <br>         } <br>     } <br>     for (int i = 0; i < n; i++) { <br>         if (nums[i] != i + 1) return i + 1; <br>     } <br>     return n + 1; <br> } </br> ```                                                                                           |
| **42. Trapping Rain Water**                                            | **Solution:** <br> ```java <br> public int trap(int[] height) { <br>     int n = height.length, left = 0, right = n - 1, water = 0; <br>     int leftMax = 0, rightMax = 0; <br>     while (left <= right) { <br>         if (height[left] <= height[right]) { <br>             if (height[left] >= leftMax) leftMax = height[left]; <br>             else water += leftMax - height[left]; <br>             left++; <br>         } else { <br>             if (height[right] >= rightMax) rightMax = height[right]; <br>             else water += rightMax - height[right]; <br>             right--; <br>         } <br>     } <br>     return water; <br> } </br> ```                                                                                                        |
| **43. Multiply Strings**                                               | **Solution:** <br> ```java <br> public String multiply(String num1, String num2) { <br>     int m = num1.length(), n = num2.length(); <br>     int[] result = new int[m + n]; <br>     for (int i = m - 1; i >= 0; i--) { <br>         for (int j = n - 1; j >= 0; j--) { <br>             int mul = (num1.charAt(i) - '0') * (num2.charAt(j) - '0'); <br>             int sum = mul + result[i + j + 1]; <br>             result[i + j + 1] = sum % 10; <br>             result[i + j] += sum / 10; <br>         } <br>     } <br>     StringBuilder sb = new StringBuilder(); <br>     for (int i : result) { <br>         if (!(sb.length() == 0 && i == 0)) sb.append(i); <br>     } <br>     return sb.length() == 0 ? "0" : sb.toString(); <br> } </br> ```                                                                                                              |
| **44. Wildcard Matching**                                              | **Solution:** <br> ```java <br> public boolean isMatch(String s, String p) { <br>     boolean[][] dp = new boolean[s.length() + 1][p.length() + 1]; <br>     dp[0][0] = true; <br>     for (int j = 1; j <= p.length(); j++) { <br>         if (p.charAt(j - 1) == '*') dp[0][j] = dp[0][j - 1]; <br>     } <br>     for (int i = 1; i <= s.length(); i++) { <br>         for (int j = 1; j <= p.length(); j++) { <br>             if (p.charAt(j - 1) == s.charAt(i - 1) || p.charAt(j - 1) == '?') { <br>                 dp[i][j] = dp[i - 1][j - 1]; <br>             } else if (p.charAt(j - 1) == '*') { <br>                 dp[i][j] = dp[i - 1][j] || dp[i][j - 1]; <br>             } <br>         } <br>     } <br>     return dp[s.length()][p.length()]; <br> } </br> ```                                                                                                          |
| **45. Jump Game II**                                                   | **Solution:** <br> ```java <br> public int jump(int[] nums) { <br>     int jumps = 0, currentEnd = 0, furthest = 0; <br>     for (int i = 0; i < nums.length - 1; i++) { <br>         furthest = Math.max(furthest, i + nums[i]); <br>         if (i == currentEnd) { <br>             jumps++; <br>             currentEnd = furthest; <br>         } <br>     } <br>     return jumps; <br> } </br> ```                                                                                                       |
| **46. Permutations**                                                   | **Solution:** <br> ```java <br> public List<List<Integer>> permute(int[] nums) { <br>     List<List<Integer>> result = new ArrayList<>(); <br>     backtrack(result, new ArrayList<>(), nums); <br>     return result; <br> } <br> private void backtrack(List<List<Integer>> result, List<Integer> temp, int[] nums) { <br>     if (temp.size() == nums.length) { <br>         result.add(new ArrayList<>(temp)); <br>         return; <br>     } <br>     for (int i = 0; i < nums.length; i++) { <br>         if (temp.contains(nums[i])) continue; <br>         temp.add(nums[i]); <br>         backtrack(result, temp, nums); <br>         temp.remove(temp.size() - 1); <br>     } <br> } </br> ```                                                                                                                   |
| **47. Permutations II**                                                 | **Solution:** <br> ```java <br> public List<List<Integer>> permuteUnique(int[] nums) { <br>     List<List<Integer>> result = new ArrayList<>(); <br>     Arrays.sort(nums); <br>     backtrack(result, new ArrayList<>(), nums, new boolean[nums.length]); <br>     return result; <br> } <br> private void backtrack(List<List<Integer>> result, List<Integer> temp, int[] nums, boolean[] used) { <br>     if (temp.size() == nums.length) { <br>         result.add(new ArrayList<>(temp)); <br>         return; <br>     } <br>     for (int i = 0; i < nums.length; i++) { <br>         if (used[i] || (i > 0 && nums[i] == nums[i - 1] && !used[i - 1])) continue; <br>         used[i] = true; <br>         temp.add(nums[i]); <br>         backtrack(result, temp, nums, used); <br>         used[i] = false; <br>         temp.remove(temp.size() - 1); <br>     } <br> } </br> ```                                                                                                                       |
| **48. Rotate Image**                                                   | **Solution:** <br> ```java <br> public void rotate(int[][] matrix) { <br>     int n = matrix.length; <br>     for (int i = 0; i < n / 2; i++) { <br>         for (int j = i; j < n - i - 1; j++) { <br>             int temp = matrix[i][j]; <br>             matrix[i][j] = matrix[n - j - 1][i]; <br>             matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]; <br>             matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]; <br>             matrix[j][n - i - 1] = temp; <br>         } <br>     } <br> } </br> ```                                                                                                           |
| **49. Group Anagrams**                                                 | **Solution:** <br> ```java <br> public List<List<String>> groupAnagrams(String[] strs) { <br>     Map<String, List<String>> map = new HashMap<>(); <br>     for (String str : strs) { <br>         char[] chars = str.toCharArray(); <br>         Arrays.sort(chars); <br>         String sorted = new String(chars); <br>         map.putIfAbsent(sorted, new ArrayList<>()); <br>         map.get(sorted).add(str); <br>     } <br>     return new ArrayList<>(map.values()); <br> } </br> ```                                                                                                      |
| **50. Pow(x, n)**                                                      | **Solution:** <br> ```java <br> public double myPow(double x, int n) { <br>     if (n == 0) return 1; <br>     if (n < 0) { <br>         x = 1 / x; <br>         n = -n; <br>     } <br>     double result = 1; <br>     while (n > 0) { <br>         if (n % 2 == 1) result *= x; <br>         x *= x; <br>         n /= 2; <br>     } <br>     return result; <br> } </br> ```                                                                                                       |
| **Question**                                                          | **Answer**                                                                                                                                                                                                                                                                                                                                                         |
|----------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **51. N-Queens**                                                     | **Solution:** <br> ```java <br> public List<List<String>> solveNQueens(int n) { <br>     List<List<String>> result = new ArrayList<>(); <br>     solve(result, new ArrayList<>(), new boolean[n], new boolean[2 * n - 1], new boolean[2 * n - 1], n, 0); <br>     return result; <br> } <br> private void solve(List<List<String>> result, List<String> temp, boolean[] cols, boolean[] diag1, boolean[] diag2, int n, int row) { <br>     if (row == n) { <br>         result.add(new ArrayList<>(temp)); <br>         return; <br>     } <br>     for (int col = 0; col < n; col++) { <br>         if (cols[col] || diag1[row + col] || diag2[row - col + n - 1]) continue; <br>         cols[col] = diag1[row + col] = diag2[row - col + n - 1] = true; <br>         StringBuilder sb = new StringBuilder(); <br>         for (int i = 0; i < n; i++) sb.append(i == col ? 'Q' : '.'); <br>         temp.add(sb.toString()); <br>         solve(result, temp, cols, diag1, diag2, n, row + 1); <br>         temp.remove(temp.size() - 1); <br>         cols[col] = diag1[row + col] = diag2[row - col + n - 1] = false; <br>     } <br> } </br> ```                                                                                                           |
| **52. N-Queens II**                                                  | **Solution:** <br> ```java <br> public int totalNQueens(int n) { <br>     int[] result = new int[1]; <br>     solve(result, new boolean[n], new boolean[2 * n - 1], new boolean[2 * n - 1], n, 0); <br>     return result[0]; <br> } <br> private void solve(int[] result, boolean[] cols, boolean[] diag1, boolean[] diag2, int n, int row) { <br>     if (row == n) { <br>         result[0]++; <br>         return; <br>     } <br>     for (int col = 0; col < n; col++) { <br>         if (cols[col] || diag1[row + col] || diag2[row - col + n - 1]) continue; <br>         cols[col] = diag1[row + col] = diag2[row - col + n - 1] = true; <br>         solve(result, cols, diag1, diag2, n, row + 1); <br>         cols[col] = diag1[row + col] = diag2[row - col + n - 1] = false; <br>     } <br> } </br> ```                                                                                                           |
| **53. Maximum Subarray**                                             | **Solution:** <br> ```java <br> public int maxSubArray(int[] nums) { <br>     int maxSum = nums[0], currentSum = nums[0]; <br>     for (int i = 1; i < nums.length; i++) { <br>         currentSum = Math.max(nums[i], currentSum + nums[i]); <br>         maxSum = Math.max(maxSum, currentSum); <br>     } <br>     return maxSum; <br> } </br> ```                                                                                                         |
| **54. Spiral Matrix**                                                 | **Solution:** <br> ```java <br> public List<Integer> spiralOrder(int[][] matrix) { <br>     List<Integer> result = new ArrayList<>(); <br>     if (matrix.length == 0) return result; <br>     int top = 0, bottom = matrix.length - 1, left = 0, right = matrix[0].length - 1; <br>     while (top <= bottom && left <= right) { <br>         for (int i = left; i <= right; i++) result.add(matrix[top][i]); <br>         top++; <br>         for (int i = top; i <= bottom; i++) result.add(matrix[i][right]); <br>         right--; <br>         if (top <= bottom) { <br>             for (int i = right; i >= left; i--) result.add(matrix[bottom][i]); <br>             bottom--; <br>         } <br>         if (left <= right) { <br>             for (int i = bottom; i >= top; i--) result.add(matrix[i][left]); <br>             left++; <br>         } <br>     } <br>     return result; <br> } </br> ```                                                                                                                  |
| **55. Jump Game**                                                    | **Solution:** <br> ```java <br> public boolean canJump(int[] nums) { <br>     int lastPos = nums.length - 1; <br>     for (int i = nums.length - 2; i >= 0; i--) { <br>         if (i + nums[i] >= lastPos) lastPos = i; <br>     } <br>     return lastPos == 0; <br> } </br> ```                                                                                                          |
| **56. Merge Intervals**                                               | **Solution:** <br> ```java <br> public int[][] merge(int[][] intervals) { <br>     if (intervals.length == 0) return new int[0][0]; <br>     Arrays.sort(intervals, (a, b) -> a[0] - b[0]); <br>     List<int[]> result = new ArrayList<>(); <br>     int[] current = intervals[0]; <br>     for (int i = 1; i < intervals.length; i++) { <br>         if (current[1] >= intervals[i][0]) { <br>             current[1] = Math.max(current[1], intervals[i][1]); <br>         } else { <br>             result.add(current); <br>             current = intervals[i]; <br>         } <br>     } <br>     result.add(current); <br>     return result.toArray(new int[result.size()][]); <br> } </br> ```                                                                                                             |
| **57. Insert Interval**                                               | **Solution:** <br> ```java <br> public int[][] insert(int[][] intervals, int[] newInterval) { <br>     List<int[]> result = new ArrayList<>(); <br>     int i = 0; <br>     while (i < intervals.length && intervals[i][1] < newInterval[0]) { <br>         result.add(intervals[i++]); <br>     } <br>     while (i < intervals.length && intervals[i][0] <= newInterval[1]) { <br>         newInterval[0] = Math.min(newInterval[0], intervals[i][0]); <br>         newInterval[1] = Math.max(newInterval[1], intervals[i][1]); <br>         i++; <br>     } <br>     result.add(newInterval); <br>     while (i < intervals.length) { <br>         result.add(intervals[i++]); <br>     } <br>     return result.toArray(new int[result.size()][]); <br> } </br> ```                                                                                                       |
| **58. Length of Last Word**                                           | **Solution:** <br> ```java <br> public int lengthOfLastWord(String s) { <br>     int length = 0; <br>     int i = s.length() - 1; <br>     while (i >= 0 && s.charAt(i) == ' ') i--; <br>     while (i >= 0 && s.charAt(i) != ' ') { <br>         length++; <br>         i--; <br>     } <br>     return length; <br> } </br> ```                                                                                                                   |
| **59. Spiral Matrix II**                                              | **Solution:** <br> ```java <br> public int[][] generateMatrix(int n) { <br>     int[][] result = new int[n][n]; <br>     int top = 0, bottom = n - 1, left = 0, right = n - 1, num = 1; <br>     while (top <= bottom && left <= right) { <br>         for (int i = left; i <= right; i++) result[top][i] = num++; <br>         top++; <br>         for (int i = top; i <= bottom; i++) result[i][right] = num++; <br>         right--; <br>         if (top <= bottom) { <br>             for (int i = right; i >= left; i--) result[bottom][i] = num++; <br>             bottom--; <br>         } <br>         if (left <= right) { <br>             for (int i = bottom; i >= top; i--) result[i][left] = num++; <br>             left++; <br>         } <br>     } <br>     return result; <br> } </br> ```                                                                                                          |
| **60. Permutation Sequence**                                           | **Solution:** <br> ```java <br> public String getPermutation(int n, int k) { <br>     List<Integer> numbers = new ArrayList<>(); <br>     for (int i = 1; i <= n; i++) numbers.add(i); <br>     int[] factorial = new int[n + 1]; <br>     factorial[0] = 1; <br>     for (int i = 1; i <= n; i++) factorial[i] = factorial[i - 1] *
| **Question**                                                          | **Answer**                                                                                                                                                                                                                                                                                                                                                         |
|----------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **60. Permutation Sequence**                                           | **Solution:** <br> ```java <br> public String getPermutation(int n, int k) { <br>     List<Integer> numbers = new ArrayList<>(); <br>     for (int i = 1; i <= n; i++) numbers.add(i); <br>     int[] factorial = new int[n + 1]; <br>     factorial[0] = 1; <br>     for (int i = 1; i <= n; i++) factorial[i] = factorial[i - 1] * i; <br>     k--; <br>     StringBuilder result = new StringBuilder(); <br>     for (int i = 1; i <= n; i++) { <br>         int index = k / factorial[n - i]; <br>         result.append(numbers.get(index)); <br>         numbers.remove(index); <br>         k %= factorial[n - i]; <br>     } <br>     return result.toString(); <br> } </br> ```                                                                                                                       |
| **61. Rotate List**                                                   | **Solution:** <br> ```java <br> public ListNode rotateRight(ListNode head, int k) { <br>     if (head == null || k == 0) return head; <br>     ListNode current = head; <br>     int length = 1; <br>     while (current.next != null) { <br>         current = current.next; <br>         length++; <br>     } <br>     current.next = head; <br>     k %= length; <br>     for (int i = 0; i < length - k; i++) current = current.next; <br>     ListNode newHead = current.next; <br>     current.next = null; <br>     return newHead; <br> } </br> ```                                                                                                    |
| **62. Unique Paths**                                                  | **Solution:** <br> ```java <br> public int uniquePaths(int m, int n) { <br>     int[][] dp = new int[m][n]; <br>     for (int i = 0; i < m; i++) dp[i][0] = 1; <br>     for (int j = 0; j < n; j++) dp[0][j] = 1; <br>     for (int i = 1; i < m; i++) { <br>         for (int j = 1; j < n; j++) { <br>             dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; <br>         } <br>     } <br>     return dp[m - 1][n - 1]; <br> } </br> ```                                                                                                                      |
| **63. Unique Paths II**                                               | **Solution:** <br> ```java <br> public int uniquePathsWithObstacles(int[][] obstacleGrid) { <br>     if (obstacleGrid[0][0] == 1) return 0; <br>     int m = obstacleGrid.length, n = obstacleGrid[0].length; <br>     int[][] dp = new int[m][n]; <br>     dp[0][0] = 1; <br>     for (int i = 1; i < m; i++) dp[i][0] = obstacleGrid[i][0] == 0 ? dp[i - 1][0] : 0; <br>     for (int j = 1; j < n; j++) dp[0][j] = obstacleGrid[0][j] == 0 ? dp[0][j - 1] : 0; <br>     for (int i = 1; i < m; i++) { <br>         for (int j = 1; j < n; j++) { <br>             dp[i][j] = obstacleGrid[i][j] == 0 ? dp[i - 1][j] + dp[i][j - 1] : 0; <br>         } <br>     } <br>     return dp[m - 1][n - 1]; <br> } </br> ```                                                                                               |
| **64. Minimum Path Sum**                                              | **Solution:** <br> ```java <br> public int minPathSum(int[][] grid) { <br>     int m = grid.length, n = grid[0].length; <br>     for (int i = 1; i < m; i++) grid[i][0] += grid[i - 1][0]; <br>     for (int j = 1; j < n; j++) grid[0][j] += grid[0][j - 1]; <br>     for (int i = 1; i < m; i++) { <br>         for (int j = 1; j < n; j++) { <br>             grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]); <br>         } <br>     } <br>     return grid[m - 1][n - 1]; <br> } </br> ```                                                                                                      |
| **65. Valid Number**                                                  | **Solution:** <br> ```java <br> public boolean isNumber(String s) { <br>     s = s.trim(); <br>     if (s.isEmpty()) return false; <br>     boolean numberSeen = false, dotSeen = false, eSeen = false; <br>     for (int i = 0; i < s.length(); i++) { <br>         char c = s.charAt(i); <br>         if (c == '.') { <br>             if (dotSeen || eSeen) return false; <br>             dotSeen = true; <br>         } else if (c == 'e') { <br>             if (eSeen || !numberSeen) return false; <br>             eSeen = true; <br>         } else if (c == '+' || c == '-') { <br>             if (i > 0 && s.charAt(i - 1) != 'e') return false; <br>         } else if (c < '0' || c > '9') { <br>             return false; <br>         } else { <br>             numberSeen = true; <br>         } <br>     } <br>     return numberSeen; <br> } </br> ```                                                                                                      |
| **66. Plus One**                                                      | **Solution:** <br> ```java <br> public int[] plusOne(int[] digits) { <br>     for (int i = digits.length - 1; i >= 0; i--) { <br>         if (digits[i] < 9) { <br>             digits[i]++; <br>             return digits; <br>         } <br>         digits[i] = 0; <br>     } <br>     int[] result = new int[digits.length + 1]; <br>     result[0] = 1; <br>     return result; <br> } </br> ```                                                                                                                  |
| **67. Add Binary**                                                    | **Solution:** <br> ```java <br> public String addBinary(String a, String b) { <br>     StringBuilder result = new StringBuilder(); <br>     int i = a.length() - 1, j = b.length() - 1, carry = 0; <br>     while (i >= 0 || j >= 0 || carry != 0) { <br>         int sum = carry; <br>         if (i >= 0) sum += a.charAt(i--) - '0'; <br>         if (j >= 0) sum += b.charAt(j--) - '0'; <br>         carry = sum / 2; <br>         result.append(sum % 2); <br>     } <br>     return result.reverse().toString(); <br> } </br> ```                                                                                                                 |
| **68. Text Justification**                                            | **Solution:** <br> ```java <br> public List<String> fullJustify(String[] words, int maxWidth) { <br>     List<String> result = new ArrayList<>(); <br>     List<String> current = new ArrayList<>(); <br>     int currentLength = 0; <br>     for (String word : words) { <br>         if (currentLength + current.size() + word.length() > maxWidth) { <br>             result.add(justify(current, currentLength, maxWidth, false)); <br>             current.clear(); <br>             currentLength = 0; <br>         } <br>         current.add(word); <br>         currentLength += word.length(); <br>     } <br>     result.add(justify(current, currentLength, maxWidth, true)); <br>     return result; <br> } <br> private String justify(List<String> current, int currentLength, int maxWidth, boolean isLast) { <br>     int spaces = maxWidth - currentLength; <br>     if (current.size() == 1 || isLast) { <br>         return String.join(" ", current) + " ".repeat(spaces); <br>     } <br>     int spacePerWord = spaces / (current.size() - 1); <br>     int extraSpaces = spaces % (current.size() - 1); <br>     StringBuilder sb = new StringBuilder(); <br>     for (int i = 0; i < current.size() - 1; i++) { <br>         sb.append(current.get(i)); <br>         sb.append(" ".repeat(spacePerWord)); <br>         if (i < extraSpaces) sb.append(" "); <br>     } <br>     sb.append(current.get(current.size() - 1)); <br>     return sb.toString(); <br> } </br> ```                                                                                                           |
| **69. Sqrt(x)**                                                      | **Solution:** <br> ```java <br> public int mySqrt(int x) { <br>     if (x == 0) return 0; <br>     int left = 1, right = x; <br>     while (left <= right) { <br>         int mid = left + (right - left) / 2; <br>         if (mid == x / mid) return mid; <br>         if (mid < x / mid) left = mid + 1; <br>         else right = mid - 1; <br>     } <br>     return right; <br> } </br> ```                                                                                                           |
| **70. Climbing Stairs**                                               | **Solution:** <br> ```java <br> public int climbStairs(int n) { <br>     if (n <= 2) return n; <br>     int first = 1, second = 2; <br>     for (int i = 3; i <= n; i++) { <br>         int temp = first + second; <br>         first = second; <br>         second = temp; <br>     } <br>     return second; <br> } </br> ```                                                                                                    |
| **71. Simplify Path**                                                 | **Solution:** <br> ```java <br> public String simplifyPath(String path) { <br>     Stack<String> stack = new Stack<>(); <br>     String[] parts = path.split("/"); <br>     for (String part : parts) { <br>         if (part.equals("") || part.equals(".")) continue; <br>         if (part.equals("..")) { <br>             if (!stack.isEmpty()) stack.pop(); <br>         } else { <br>             stack.push(part); <br>         } <br>     } <br>     StringBuilder result = new StringBuilder(); <br>     for (String part : stack) result.append("/").append(part); <br>     return result.length() == 0 ? "/" : result.toString(); <br> } </br> ```                                                                                      |
| **Question**                                                           | **Answer**                                                                                                                                                                                                                                                                                                                                                         |
|-----------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **72. Edit Distance**                                                 | **Solution:** <br> ```java <br> public int minDistance(String word1, String word2) { <br>     int m = word1.length(), n = word2.length(); <br>     int[][] dp = new int[m + 1][n + 1]; <br>     for (int i = 0; i <= m; i++) dp[i][0] = i; <br>     for (int j = 0; j <= n; j++) dp[0][j] = j; <br>     for (int i = 1; i <= m; i++) { <br>         for (int j = 1; j <= n; j++) { <br>             if (word1.charAt(i - 1) == word2.charAt(j - 1)) { <br>                 dp[i][j] = dp[i - 1][j - 1]; <br>             } else { <br>                 dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1; <br>             } <br>         } <br>     } <br>     return dp[m][n]; <br> } </br> ```                                                                                                         |
| **73. Set Matrix Zeroes**                                             | **Solution:** <br> ```java <br> public void setZeroes(int[][] matrix) { <br>     boolean firstRowZero = false, firstColZero = false; <br>     int m = matrix.length, n = matrix[0].length; <br>     for (int i = 0; i < m; i++) { <br>         if (matrix[i][0] == 0) firstColZero = true; <br>     } <br>     for (int j = 0; j < n; j++) { <br>         if (matrix[0][j] == 0) firstRowZero = true; <br>     } <br>     for (int i = 1; i < m; i++) { <br>         for (int j = 1; j < n; j++) { <br>             if (matrix[i][j] == 0) { <br>                 matrix[i][0] = 0; <br>                 matrix[0][j] = 0; <br>             } <br>         } <br>     } <br>     for (int i = 1; i < m; i++) { <br>         for (int j = 1; j < n; j++) { <br>             if (matrix[i][0] == 0 || matrix[0][j] == 0) { <br>                 matrix[i][j] = 0; <br>             } <br>         } <br>     } <br>     if (firstRowZero) { <br>         for (int j = 0; j < n; j++) { <br>             matrix[0][j] = 0; <br>         } <br>     } <br>     if (firstColZero) { <br>         for (int i = 0; i < m; i++) { <br>             matrix[i][0] = 0; <br>         } <br>     } <br> } </br> ```                                                                                                                  |
| **74. Search a 2D Matrix**                                            | **Solution:** <br> ```java <br> public boolean searchMatrix(int[][] matrix, int target) { <br>     if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return false; <br>     int m = matrix.length, n = matrix[0].length; <br>     int left = 0, right = m * n - 1; <br>     while (left <= right) { <br>         int mid = left + (right - left) / 2; <br>         int midVal = matrix[mid / n][mid % n]; <br>         if (midVal == target) return true; <br>         if (midVal < target) left = mid + 1; <br>         else right = mid - 1; <br>     } <br>     return false; <br> } </br> ```                                                                                                                             |
| **75. Sort Colors**                                                   | **Solution:** <br> ```java <br> public void sortColors(int[] nums) { <br>     int low = 0, high = nums.length - 1, mid = 0; <br>     while (mid <= high) { <br>         if (nums[mid] == 0) { <br>             swap(nums, low++, mid++); <br>         } else if (nums[mid] == 2) { <br>             swap(nums, mid, high--); <br>         } else { <br>             mid++; <br>         } <br>     } <br> } <br> private void swap(int[] nums, int i, int j) { <br>     int temp = nums[i]; <br>     nums[i] = nums[j]; <br>     nums[j] = temp; <br> } </br> ```                                                                                                                        |
| **76. Minimum Window Substring**                                      | **Solution:** <br> ```java <br> public String minWindow(String s, String t) { <br>     int[] countT = new int[256], countS = new int[256]; <br>     for (char c : t.toCharArray()) countT[c]++; <br>     int start = 0, end = 0, minLen = Integer.MAX_VALUE, minStart = 0; <br>     int required = t.length(), formed = 0; <br>     while (end < s.length()) { <br>         if (countT[s.charAt(end)] > 0 && countS[s.charAt(end)] < countT[s.charAt(end)]) { <br>             formed++; <br>         } <br>         countS[s.charAt(end)]++; <br>         while (start <= end && formed == required) { <br>             if (end - start + 1 < minLen) { <br>                 minLen = end - start + 1; <br>                 minStart = start; <br>             } <br>             countS[s.charAt(start)]--; <br>             if (countT[s.charAt(start)] > 0 && countS[s.charAt(start)] < countT[s.charAt(start)]) { <br>                 formed--; <br>             } <br>             start++; <br>         } <br>         end++; <br>     } <br>     return minLen == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLen); <br> } </br> ```                                                                                                                       |
| **77. Combinations**                                                  | **Solution:** <br> ```java <br> public List<List<Integer>> combine(int n, int k) { <br>     List<List<Integer>> result = new ArrayList<>(); <br>     backtrack(result, new ArrayList<>(), n, k, 1); <br>     return result; <br> } <br> private void backtrack(List<List<Integer>> result, List<Integer> current, int n, int k, int start) { <br>     if (current.size() == k) { <br>         result.add(new ArrayList<>(current)); <br>         return; <br>     } <br>     for (int i = start; i <= n; i++) { <br>         current.add(i); <br>         backtrack(result, current, n, k, i + 1); <br>         current.remove(current.size() - 1); <br>     } <br> } </br> ```                                                                                                         |
| **78. Subsets**                                                       | **Solution:** <br> ```java <br> public List<List<Integer>> subsets(int[] nums) { <br>     List<List<Integer>> result = new ArrayList<>(); <br>     result.add(new ArrayList<>()); <br>     for (int num : nums) { <br>         int size = result.size(); <br>         for (int i = 0; i < size; i++) { <br>             List<Integer> subset = new ArrayList<>(result.get(i)); <br>             subset.add(num); <br>             result.add(subset); <br>         } <br>     } <br>     return result; <br> } </br> ```                                                                                                    |
| **79. Word Search**                                                   | **Solution:** <br> ```java <br> public boolean exist(char[][] board, String word) { <br>     int m = board.length, n = board[0].length; <br>     for (int i = 0; i < m; i++) { <br>         for (int j = 0; j < n; j++) { <br>             if (dfs(board, word, i, j, 0)) return true; <br>         } <br>     } <br>     return false; <br> } <br> private boolean dfs(char[][] board, String word, int i, int j, int index) { <br>     if (index == word.length()) return true; <br>     if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] != word.charAt(index)) return false; <br>     char temp = board[i][j]; <br>     board[i][j] = '#'; <br>     boolean found = dfs(board, word, i + 1, j, index + 1) || dfs(board, word, i - 1, j, index + 1) || dfs(board, word, i, j + 1, index + 1) || dfs(board, word, i, j - 1, index + 1); <br>     board[i][j] = temp; <br>     return found; <br> } </br> ```                                                                                   |
| **Question**                                                           | **Answer**                                                                                                                                                                                                                                                                                                                                                         |
|-----------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **80. Remove Duplicates from Sorted Array II**                        | **Solution:** <br> ```java <br> public int removeDuplicates(int[] nums) { <br>     int index = 0; <br>     for (int i = 0; i < nums.length; i++) { <br>         if (index < 2 || nums[i] > nums[index - 2]) { <br>             nums[index++] = nums[i]; <br>         } <br>     } <br>     return index; <br> } </br> ```                                                                                                                        |
| **81. Search in Rotated Sorted Array II**                              | **Solution:** <br> ```java <br> public boolean search(int[] nums, int target) { <br>     int left = 0, right = nums.length - 1; <br>     while (left <= right) { <br>         int mid = left + (right - left) / 2; <br>         if (nums[mid] == target) return true; <br>         if (nums[left] == nums[mid] && nums[mid] == nums[right]) { <br>             left++; <br>             right--; <br>         } else if (nums[left] <= nums[mid]) { <br>             if (nums[left] <= target && target < nums[mid]) { <br>                 right = mid - 1; <br>             } else { <br>                 left = mid + 1; <br>             } <br>         } else { <br>             if (nums[mid] < target && target <= nums[right]) { <br>                 left = mid + 1; <br>             } else { <br>                 right = mid - 1; <br>             } <br>         } <br>     } <br>     return false; <br> } </br> ```                                                                                     |
| **82. Remove Duplicates from Sorted List II**                          | **Solution:** <br> ```java <br> public ListNode deleteDuplicates(ListNode head) { <br>     if (head == null) return head; <br>     ListNode dummy = new ListNode(0); <br>     dummy.next = head; <br>     ListNode prev = dummy, current = head; <br>     while (current != null) { <br>         while (current.next != null && current.val == current.next.val) { <br>             current = current.next; <br>         } <br>         if (prev.next != current) { <br>             prev.next = current.next; <br>         } else { <br>             prev = prev.next; <br>         } <br>         current = current.next; <br>     } <br>     return dummy.next; <br> } </br> ```                                                                                                 |
| **83. Remove Duplicates from Sorted List**                             | **Solution:** <br> ```java <br> public ListNode deleteDuplicates(ListNode head) { <br>     if (head == null) return head; <br>     ListNode current = head; <br>     while (current != null && current.next != null) { <br>         if (current.val == current.next.val) { <br>             current.next = current.next.next; <br>         } else { <br>             current = current.next; <br>         } <br>     } <br>     return head; <br> } </br> ```                                                                                       |
| **84. Largest Rectangle in Histogram**                                | **Solution:** <br> ```java <br> public int largestRectangleArea(int[] heights) { <br>     Stack<Integer> stack = new Stack<>(); <br>     int maxArea = 0; <br>     for (int i = 0; i <= heights.length; i++) { <br>         while (!stack.isEmpty() && (i == heights.length || heights[stack.peek()] > heights[i])) { <br>             int h = heights[stack.pop()]; <br>             int w = stack.isEmpty() ? i : i - stack.peek() - 1; <br>             maxArea = Math.max(maxArea, h * w); <br>         } <br>         stack.push(i); <br>     } <br>     return maxArea; <br> } </br> ```                                                                                              |
| **85. Maximal Rectangle**                                              | **Solution:** <br> ```java <br> public int maximalRectangle(char[][] matrix) { <br>     if (matrix.length == 0 || matrix[0].length == 0) return 0; <br>     int maxArea = 0, n = matrix[0].length; <br>     int[] heights = new int[n]; <br>     for (int i = 0; i < matrix.length; i++) { <br>         for (int j = 0; j < n; j++) { <br>             heights[j] = matrix[i][j] == '1' ? heights[j] + 1 : 0; <br>         } <br>         maxArea = Math.max(maxArea, largestRectangleArea(heights)); <br>     } <br>     return maxArea; <br> } <br> private int largestRectangleArea(int[] heights) { <br>     Stack<Integer> stack = new Stack<>(); <br>     int maxArea = 0; <br>     for (int i = 0; i <= heights.length; i++) { <br>         while (!stack.isEmpty() && (i == heights.length || heights[stack.peek()] > heights[i])) { <br>             int h = heights[stack.pop()]; <br>             int w = stack.isEmpty() ? i : i - stack.peek() - 1; <br>             maxArea = Math.max(maxArea, h * w); <br>         } <br>         stack.push(i); <br>     } <br>     return maxArea; <br> } </br> ```                                                                                              |
| **86. Partition List**                                                 | **Solution:** <br> ```java <br> public ListNode partition(ListNode head, int x) { <br>     ListNode smallerHead = new ListNode(0), greaterHead = new ListNode(0); <br>     ListNode smaller = smallerHead, greater = greaterHead; <br>     while (head != null) { <br>         if (head.val < x) { <br>             smaller.next = head; <br>             smaller = smaller.next; <br>         } else { <br>             greater.next = head; <br>             greater = greater.next; <br>         } <br>         head = head.next; <br>     } <br>     greater.next = null; <br>     smaller.next = greaterHead.next; <br>     return smallerHead.next; <br> } </br> ```                                                                                              |
| **87. Scramble String**                                                | **Solution:** <br> ```java <br> public boolean isScramble(String s1, String s2) { <br>     if (s1.length() != s2.length()) return false; <br>     if (s1.equals(s2)) return true; <br>     int[] count = new int[26]; <br>     for (char c : s1.toCharArray()) count[c - 'a']++; <br>     for (char c : s2.toCharArray()) count[c - 'a']--; <br>     for (int c : count) { <br>         if (c != 0) return false; <br>     } <br>     return helper(s1, s2); <br> } <br> private boolean helper(String s1, String s2) { <br>     if (s1.equals(s2)) return true; <br>     int n = s1.length(); <br>     for (int i = 1; i < n; i++) { <br>         if (helper(s1.substring(0, i), s2.substring(0, i)) && helper(s1.substring(i), s2.substring(i))) { <br>             return true; <br>         } <br>         if (helper(s1.substring(0, i), s2.substring(n - i)) && helper(s1.substring(i), s2.substring(0, n - i))) { <br>             return true; <br>         } <br>     } <br>     return false; <br> } </br> ```                                                                                                                   |
| **88. Merge Sorted Array**                                            | **Solution:** <br> ```java <br> public void merge(int[] nums1, int m, int[] nums2, int n) { <br>     int i = m - 1, j = n - 1, k = m + n - 1; <br>     while (i >= 0 && j >= 0) { <br>         if (nums1[i] > nums2[j]) { <br>             nums1[k--] = nums1[i--]; <br>         } else { <br>             nums1[k--] = nums2[j--]; <br>         } <br>     } <br>     while (j >= 0) { <br>         nums1[k--] = nums2[j--]; <br>     } <br> } </br> ```                                                                                                                       |
| **89. Gray Code**                                                     | **Solution:** <br> ```java <br> public List<Integer> grayCode(int n) { <br>     List<Integer> result = new ArrayList<>(); <br>     result.add(0); <br>     for (int i = 0; i < n; i++) { <br>         int size = result.size(); <br>         for (int j = size - 1; j >= 0; j--) { <br>             result.add(result.get(j) | (1 << i)); <br>         } <br>     } <br>     return result; <br> } </br> ```                                                                                           |
| **90. Subsets II**                                                    | **Solution:** <br> ```java <br> public List<List<Integer>> subsetsWithDup(int[] nums) { <br>     List<List<Integer>> result = new ArrayList<>(); <br>     Arrays.sort(nums); <br>     backtrack(result, new ArrayList<>(), nums, 0); <br>     return result; <br> } <br> private void backtrack(List<List<Integer>> result, List<Integer> current, int[] nums, int start) { <br>     result.add(new ArrayList<>(current)); <br>     for (int i = start; i < nums.length; i++) { <br>         if (i > start && nums[i] == nums[i - 1]) continue; <br>         current.add(nums[i]); <br>         backtrack(result, current, nums, i + 1); <br>         current.remove(current.size() - 1); <br>     } <br> } </br> ```                                                                                       |
| **Question**                                                           | **Answer**                                                                                                                                                                                                                                                                                                                                                         |
|-----------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **91. Decode Ways**                                                   | **Solution:** <br> ```java <br> public int numDecodings(String s) { <br>     if (s == null || s.length() == 0) return 0; <br>     int n = s.length(); <br>     int[] dp = new int[n + 1]; <br>     dp[0] = 1; <br>     dp[1] = s.charAt(0) != '0' ? 1 : 0; <br>     for (int i = 2; i <= n; i++) { <br>         if (s.charAt(i - 1) != '0') { <br>             dp[i] += dp[i - 1]; <br>         } <br>         if (s.charAt(i - 2) == '1' || (s.charAt(i - 2) == '2' && s.charAt(i - 1) <= '6')) { <br>             dp[i] += dp[i - 2]; <br>         } <br>     } <br>     return dp[n]; <br> } </br> ```                                                                                             |
| **92. Reverse Linked List II**                                         | **Solution:** <br> ```java <br> public ListNode reverseBetween(ListNode head, int m, int n) { <br>     if (head == null || m == n) return head; <br>     ListNode dummy = new ListNode(0); <br>     dummy.next = head; <br>     ListNode prev = dummy; <br>     for (int i = 1; i < m; i++) { <br>         prev = prev.next; <br>     } <br>     ListNode start = prev.next; <br>     ListNode then = start.next; <br>     for (int i = 0; i < n - m; i++) { <br>         start.next = then.next; <br>         then.next = prev.next; <br>         prev.next = then; <br>         then = start.next; <br>     } <br>     return dummy.next; <br> } </br> ```                                                                                                             |
| **93. Restore IP Addresses**                                           | **Solution:** <br> ```java <br> public List<String> restoreIpAddresses(String s) { <br>     List<String> result = new ArrayList<>(); <br>     if (s.length() > 12 || s.length() < 4) return result; <br>     backtrack(result, new StringBuilder(), s, 0, 0); <br>     return result; <br> } <br> private void backtrack(List<String> result, StringBuilder current, String s, int index, int segment) { <br>     if (segment == 4 && index == s.length()) { <br>         result.add(current.toString()); <br>         return; <br>     } <br>     if (segment > 4) return; <br>     for (int len = 1; len <= 3; len++) { <br>         if (index + len > s.length()) break; <br>         String str = s.substring(index, index + len); <br>         if ((str.length() > 1 && str.charAt(0) == '0') || Integer.parseInt(str) > 255) continue; <br>         int prevLength = current.length(); <br>         if (segment > 0) current.append("."); <br>         current.append(str); <br>         backtrack(result, current, s, index + len, segment + 1); <br>         current.delete(prevLength, current.length()); <br>     } <br> } </br> ```                                                                                                           |
| **94. Binary Tree Inorder Traversal**                                  | **Solution:** <br> ```java <br> public List<Integer> inorderTraversal(TreeNode root) { <br>     List<Integer> result = new ArrayList<>(); <br>     inorderHelper(root, result); <br>     return result; <br> } <br> private void inorderHelper(TreeNode node, List<Integer> result) { <br>     if (node == null) return; <br>     inorderHelper(node.left, result); <br>     result.add(node.val); <br>     inorderHelper(node.right, result); <br> } </br> ```                                                                                                   |
| **95. Unique Binary Search Trees II**                                  | **Solution:** <br> ```java <br> public List<TreeNode> generateTrees(int n) { <br>     if (n == 0) return new ArrayList<>(); <br>     return generateTreesHelper(1, n); <br> } <br> private List<TreeNode> generateTreesHelper(int start, int end) { <br>     List<TreeNode> result = new ArrayList<>(); <br>     if (start > end) { <br>         result.add(null); <br>         return result; <br>     } <br>     for (int i = start; i <= end; i++) { <br>         List<TreeNode> leftTrees = generateTreesHelper(start, i - 1); <br>         List<TreeNode> rightTrees = generateTreesHelper(i + 1, end); <br>         for (TreeNode left : leftTrees) { <br>             for (TreeNode right : rightTrees) { <br>                 TreeNode root = new TreeNode(i); <br>                 root.left = left; <br>                 root.right = right; <br>                 result.add(root); <br>             } <br>         } <br>     } <br>     return result; <br> } </br> ```                                                                                         |
| **96. Unique Binary Search Trees**                                     | **Solution:** <br> ```java <br> public int numTrees(int n) { <br>     int[] dp = new int[n + 1]; <br>     dp[0] = dp[1] = 1; <br>     for (int i = 2; i <= n; i++) { <br>         for (int j = 1; j <= i; j++) { <br>             dp[i] += dp[j - 1] * dp[i - j]; <br>         } <br>     } <br>     return dp[n]; <br> } </br> ```                                                                                             |
| **97. Interleaving String**                                             | **Solution:** <br> ```java <br> public boolean isInterleave(String s1, String s2, String s3) { <br>     if (s1.length() + s2.length() != s3.length()) return false; <br>     boolean[][] dp = new boolean[s1.length() + 1][s2.length() + 1]; <br>     dp[0][0] = true; <br>     for (int i = 1; i <= s1.length(); i++) { <br>         dp[i][0] = dp[i - 1][0] && s1.charAt(i - 1) == s3.charAt(i - 1); <br>     } <br>     for (int j = 1; j <= s2.length(); j++) { <br>         dp[0][j] = dp[0][j - 1] && s2.charAt(j - 1) == s3.charAt(j - 1); <br>     } <br>     for (int i = 1; i <= s1.length(); i++) { <br>         for (int j = 1; j <= s2.length(); j++) { <br>             dp[i][j] = (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) || (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1)); <br>         } <br>     } <br>     return dp[s1.length()][s2.length()]; <br> } </br> ```                                                                                                        |
| **98. Validate Binary Search Tree**                                    | **Solution:** <br> ```java <br> public boolean isValidBST(TreeNode root) { <br>     return isValidBSTHelper(root, Long.MIN_VALUE, Long.MAX_VALUE); <br> } <br> private boolean isValidBSTHelper(TreeNode node, long min, long max) { <br>     if (node == null) return true; <br>     if (node.val <= min || node.val >= max) return false; <br>     return isValidBSTHelper(node.left, min, node.val) && isValidBSTHelper(node.right, node.val, max); <br> } </br> ```                                                                                              |
| **99. Recover Binary Search Tree**                                     | **Solution:** <br> ```java <br> public void recoverTree(TreeNode root) { <br>     TreeNode first = null, second = null, prev = new TreeNode(Long.MIN_VALUE); <br>     inorderTraversal(root, prev, first, second); <br>     swap(first, second); <br> } <br> private void inorderTraversal(TreeNode node, TreeNode prev, TreeNode first, TreeNode second) { <br>     if (node == null) return; <br>     inorderTraversal(node.left, prev, first, second); <br>     if (first == null && prev.val >= node.val) first = prev; <br>     if (first != null && prev.val >= node.val) second = node; <br>     prev = node; <br>     inorderTraversal(node.right, prev, first, second); <br> } <br> private void swap(TreeNode first, TreeNode second) { <br>     int temp = first.val; <br>     first.val = second.val; <br>     second.val = temp; <br> } </br> ```                                                                                             |
| **100. Same Tree**                                                     | **Solution:** <br> ```java <br> public boolean isSameTree(TreeNode p, TreeNode q) { <br>     if (p == null && q == null) return true; <br>     if (p == null || q == null) return false; <br>     return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right); <br> } </br> ```                                                                                   |
| **Question**                                                           | **Answer**                                                                                                                                                                                                                                                                                                                                                         |
|-----------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **101. Symmetric Tree**                                                | **Solution:** <br> ```java <br> public boolean isSymmetric(TreeNode root) { <br>     if (root == null) return true; <br>     return isMirror(root.left, root.right); <br> } <br> private boolean isMirror(TreeNode t1, TreeNode t2) { <br>     if (t1 == null && t2 == null) return true; <br>     if (t1 == null || t2 == null) return false; <br>     return (t1.val == t2.val) && isMirror(t1.left, t2.right) && isMirror(t1.right, t2.left); <br> } </br> ```                                                                                              |
| **102. Binary Tree Level Order Traversal**                              | **Solution:** <br> ```java <br> public List<List<Integer>> levelOrder(TreeNode root) { <br>     List<List<Integer>> result = new ArrayList<>(); <br>     if (root == null) return result; <br>     Queue<TreeNode> queue = new LinkedList<>(); <br>     queue.offer(root); <br>     while (!queue.isEmpty()) { <br>         int size = queue.size(); <br>         List<Integer> level = new ArrayList<>(); <br>         for (int i = 0; i < size; i++) { <br>             TreeNode node = queue.poll(); <br>             level.add(node.val); <br>             if (node.left != null) queue.offer(node.left); <br>             if (node.right != null) queue.offer(node.right); <br>         } <br>         result.add(level); <br>     } <br>     return result; <br> } </br> ```                                                                                          |
| **103. Binary Tree Zigzag Level Order Traversal**                      | **Solution:** <br> ```java <br> public List<List<Integer>> zigzagLevelOrder(TreeNode root) { <br>     List<List<Integer>> result = new ArrayList<>(); <br>     if (root == null) return result; <br>     Queue<TreeNode> queue = new LinkedList<>(); <br>     queue.offer(root); <br>     boolean leftToRight = true; <br>     while (!queue.isEmpty()) { <br>         int size = queue.size(); <br>         List<Integer> level = new ArrayList<>(); <br>         for (int i = 0; i < size; i++) { <br>             TreeNode node = queue.poll(); <br>             if (leftToRight) level.add(node.val); <br>             else level.add(0, node.val); <br>             if (node.left != null) queue.offer(node.left); <br>             if (node.right != null) queue.offer(node.right); <br>         } <br>         result.add(level); <br>         leftToRight = !leftToRight; <br>     } <br>     return result; <br> } </br> ```                                                                                                        |
| **104. Maximum Depth of Binary Tree**                                  | **Solution:** <br> ```java <br> public int maxDepth(TreeNode root) { <br>     if (root == null) return 0; <br>     int leftDepth = maxDepth(root.left); <br>     int rightDepth = maxDepth(root.right); <br>     return Math.max(leftDepth, rightDepth) + 1; <br> } </br> ```                                                                                                        |
| **105. Construct Binary Tree from Preorder and Inorder Traversal**     | **Solution:** <br> ```java <br> public TreeNode buildTree(int[] preorder, int[] inorder) { <br>     return buildTreeHelper(preorder, inorder, 0, 0, inorder.length - 1); <br> } <br> private TreeNode buildTreeHelper(int[] preorder, int[] inorder, int preStart, int inStart, int inEnd) { <br>     if (inStart > inEnd) return null; <br>     TreeNode root = new TreeNode(preorder[preStart]); <br>     int rootIndex = 0; <br>     for (int i = inStart; i <= inEnd; i++) { <br>         if (inorder[i] == preorder[preStart]) { <br>             rootIndex = i; <br>             break; <br>         } <br>     } <br>     root.left = buildTreeHelper(preorder, inorder, preStart + 1, inStart, rootIndex - 1); <br>     root.right = buildTreeHelper(preorder, inorder, preStart + rootIndex - inStart + 1, rootIndex + 1, inEnd); <br>     return root; <br> } </br> ```                                                                                              |
| **106. Construct Binary Tree from Inorder and Postorder Traversal**    | **Solution:** <br> ```java <br> public TreeNode buildTree(int[] inorder, int[] postorder) { <br>     return buildTreeHelper(inorder, postorder, inorder.length - 1, 0, inorder.length - 1); <br> } <br> private TreeNode buildTreeHelper(int[] inorder, int[] postorder, int postStart, int inStart, int inEnd) { <br>     if (inStart > inEnd) return null; <br>     TreeNode root = new TreeNode(postorder[postStart]); <br>     int rootIndex = 0; <br>     for (int i = inStart; i <= inEnd; i++) { <br>         if (inorder[i] == postorder[postStart]) { <br>             rootIndex = i; <br>             break; <br>         } <br>     } <br>     root.right = buildTreeHelper(inorder, postorder, postStart - 1, rootIndex + 1, inEnd); <br>     root.left = buildTreeHelper(inorder, postorder, postStart - (inEnd - rootIndex + 1), inStart, rootIndex - 1); <br>     return root; <br> } </br> ```                                                                                             |
| **107. Binary Tree Level Order Traversal II**                          | **Solution:** <br> ```java <br> public List<List<Integer>> levelOrderBottom(TreeNode root) { <br>     List<List<Integer>> result = new ArrayList<>(); <br>     if (root == null) return result; <br>     Queue<TreeNode> queue = new LinkedList<>(); <br>     queue.offer(root); <br>     while (!queue.isEmpty()) { <br>         int size = queue.size(); <br>         List<Integer> level = new ArrayList<>(); <br>         for (int i = 0; i < size; i++) { <br>             TreeNode node = queue.poll(); <br>             level.add(node.val); <br>             if (node.left != null) queue.offer(node.left); <br>             if (node.right != null) queue.offer(node.right); <br>         } <br>         result.add(0, level); <br>     } <br>     return result; <br> } </br> ```                                                                                                         |
| **108. Convert Sorted Array to Binary Search Tree**                    | **Solution:** <br> ```java <br> public TreeNode sortedArrayToBST(int[] nums) { <br>     return sortedArrayToBSTHelper(nums, 0, nums.length - 1); <br> } <br> private TreeNode sortedArrayToBSTHelper(int[] nums, int start, int end) { <br>     if (start > end) return null; <br>     int mid = (start + end) / 2; <br>     TreeNode node = new TreeNode(nums[mid]); <br>     node.left = sortedArrayToBSTHelper(nums, start, mid - 1); <br>     node.right = sortedArrayToBSTHelper(nums, mid + 1, end); <br>     return node; <br> } </br> ```                                                                                       |
| **109. Convert Sorted List to Binary Search Tree**                     | **Solution:** <br> ```java <br> public TreeNode sortedListToBST(ListNode head) { <br>     if (head == null) return null; <br>     return sortedListToBSTHelper(head, null); <br> } <br> private TreeNode sortedListToBSTHelper(ListNode head, ListNode tail) { <br>     if (head == tail) return null; <br>     ListNode slow = head, fast = head; <br>     while (fast != tail && fast.next != tail) { <br>         slow = slow.next; <br>         fast = fast.next.next; <br>     } <br>     TreeNode root = new TreeNode(slow.val); <br>     root.left = sortedListToBSTHelper(head, slow); <br>     root.right = sortedListToBSTHelper(slow.next, tail); <br>     return root; <br> } </br> ```                                                                                             |
| **110. Balanced Binary Tree**                                           | **Solution:** <br> ```java <br> public boolean isBalanced(TreeNode root) { <br>     return height(root) != -1; <br> } <br> private int height(TreeNode root) { <br>     if (root == null) return 0; <br>     int leftHeight = height(root.left); <br>     int rightHeight = height(root.right); <br>     if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) > 1) return -1; <br>     return Math.max(leftHeight, rightHeight) + 1; <br> } </br> ```                                                                                       |
