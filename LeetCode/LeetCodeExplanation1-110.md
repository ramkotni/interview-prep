# LeetCode Problems and Explanations (1-110)

| **Problem Statement** | **Explanation** |
|-----------------------|-----------------|
| **1. Two Sum** <br> Given an array of integers, return the indices of the two numbers such that they add up to a specific target. | The problem is solved using a HashMap to store the difference between the target and the current number. For each new number, check if the difference exists in the HashMap. If found, return their indices. |
| **2. Add Two Numbers** <br> You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. | This problem involves adding corresponding digits of two numbers in reverse order. You need to take care of the carry, and iterate over the linked lists. If one list is shorter, continue with the other list. |
| **3. Longest Substring Without Repeating Characters** <br> Given a string, find the length of the longest substring without repeating characters. | The solution uses a sliding window approach with two pointers. We move the right pointer to expand the window and the left pointer to shrink it when duplicates are encountered. |
| **4. Median of Two Sorted Arrays** <br> Given two sorted arrays, find the median of the two sorted arrays. The overall run time complexity should be O(log(min(n, m))). | A binary search approach is used to partition the two arrays such that the left partition contains smaller elements than the right. Then, the median is calculated from the partitioned elements. |
| **5. Longest Palindromic Substring** <br> Given a string, return the longest palindromic substring. | The solution uses the center expansion technique, where we expand from each character (and pair of characters) to find the longest palindrome in the string. |
| **6. Zigzag Conversion** <br> The string is written in a zigzag pattern on a given number of rows. Write a function to convert it back to the original string. | The solution simulates the zigzag traversal by iterating through the rows and collecting characters for each row at intervals, taking care of the character placement in a zigzag fashion. |
| **7. Reverse Integer** <br> Given a 32-bit signed integer, reverse the digits of the integer. | The solution uses modular arithmetic to extract the last digit of the number and builds the reversed number while handling the sign and overflow cases. |
| **8. String to Integer (atoi)** <br> Implement the `atoi` function, which converts a string to an integer. | The approach involves skipping leading whitespaces, handling signs, and converting the string to an integer by iterating through the string and constructing the integer. |
| **9. Palindrome Number** <br> Given an integer, return true if it is a palindrome number. | The number is checked for palindrome properties by reversing half of the digits and comparing it with the other half. Special care is taken for negative numbers and numbers divisible by 10. |
| **10. Regular Expression Matching** <br> Implement regular expression matching with support for `.` and `*`. | The solution uses dynamic programming to match characters, where `.` matches any single character and `*` matches zero or more of the preceding element. |
| **11. Container With Most Water** <br> Given an array of non-negative integers, find two lines that together with the x-axis form a container that holds the most water. | A two-pointer approach is used where we start with pointers at both ends of the array, calculate the area, and then move the pointer pointing to the shorter line inwards to maximize the area. |
| **12. Integer to Roman** <br> Convert an integer to a Roman numeral. | The solution uses predefined mappings for Roman numerals and subtracts values from the integer while appending the corresponding Roman numeral symbols. |
| **13. Roman to Integer** <br> Given a Roman numeral, convert it to an integer. | The solution involves iterating through the Roman numeral, checking if the current numeral is smaller than the next numeral (for cases like "IV" and "IX") and adding or subtracting accordingly. |
| **14. Longest Common Prefix** <br> Write a function to find the longest common prefix string amongst an array of strings. | The approach uses vertical scanning, comparing characters at each position across all strings until a mismatch is found. The common prefix is then returned. |
| **15. 3Sum** <br> Given an array of integers, return all unique triplets in the array that sum up to zero. | The solution involves sorting the array and using a two-pointer approach to find pairs that sum up to the negative of the current number. Duplicates are avoided by skipping repeated elements. |
| **16. 3Sum Closest** <br> Given an array of integers, find the sum of the three integers that is closest to a given target. | The solution is similar to 3Sum but instead of looking for zero, we compute the sum and update the closest sum while adjusting the pointers to get the closest value to the target. |
| **17. Letter Combinations of a Phone Number** <br> Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. | The solution uses a backtracking approach, where for each digit, the corresponding letters are considered and combinations are built recursively. |
| **18. 4Sum** <br> Given an array of integers, return all unique quadruplets in the array that sum up to a target value. | The solution uses a similar approach to 3Sum by fixing one element and using a two-pointer approach for the remaining elements. |
| **19. Remove Nth Node From End of List** <br> Given a linked list, remove the n-th node from the end of the list and return its head. | The solution uses two pointers, one moving `n` steps ahead and then both pointers moving together to find the node to be removed. |
| **20. Valid Parentheses** <br> Given a string containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['`, and `']'`, determine if the input string is valid. | The solution uses a stack to keep track of the opening parentheses. For each closing parenthesis, the stack is checked to ensure it matches the last opened parenthesis. |
| **21. Merge Two Sorted Lists** <br> Merge two sorted linked lists and return it as a new sorted list. | The solution uses two pointers, one for each list, and compares the nodes, appending the smaller node to the result list until one of the lists is exhausted. |
| **22. Generate Parentheses** <br> Given `n` pairs of parentheses, write a function to generate all combinations of well-formed parentheses. | The solution uses backtracking to build the combinations by adding opening and closing parentheses as long as the conditions for valid parentheses are met. |
| **23. Merge k Sorted Lists** <br> Merge `k` sorted linked lists into one sorted linked list. | The solution uses a priority queue (min-heap) to efficiently merge the lists by inserting the smallest element from each list. |
| **24. Swap Nodes in Pairs** <br> Given a linked list, swap every two adjacent nodes and return its head. | The solution involves iterating over the list in pairs, swapping the nodes, and adjusting the links accordingly. |
| **25. Reverse Nodes in k-Group** <br> Given a linked list, reverse the nodes of a linked list `k` at a time and return its modified list. | The solution involves reversing each group of `k` nodes and using a recursive approach to handle subsequent groups. |
| **26. Remove Duplicates from Sorted Array** <br> Given a sorted array, remove the duplicates in-place such that each element appears only once. Return the new length. | The solution uses the two-pointer technique to maintain the position of unique elements while iterating through the array and removing duplicates. |
| **27. Remove Element** <br> Given an array and a value, remove all instances of that value in-place and return the new length. | The solution uses two pointers: one for iterating through the array and the other for overwriting the elements that do not match the given value. |
| **28. Implement strStr()** <br> Implement the `strStr()` function, which locates a substring within a string. | The solution uses a sliding window approach to compare the substring and the string, and returns the index where the substring is found. |
| **29. Divide Two Integers** <br> Divide two integers without using multiplication, division, or mod operator. | The solution uses bitwise shifts to perform division by approximating the quotient with repeated subtractions. |
| **30. Substring with Concatenation of All Words** <br> You are given a string and a list of words. Return all starting indices of the substring(s) that is a concatenation of each word in the list exactly once. | The solution uses a sliding window approach where each word is mapped and checked to ensure the concatenated substring matches the given list of words. |
| **31. Next Permutation** <br> Implement the next permutation, which rearranges numbers into the lexicographically next greater permutation. | The solution finds the largest pair where the number decreases and swaps the numbers in the right half of the array to get the next permutation. |
| **32. Longest Valid Parentheses** <br> Given a string containing just `'('` and `')'`, find the length of the longest valid (well-formed) parentheses substring. | The solution uses a stack to keep track of the indices of the parentheses. When a valid pair is found, the length of the valid substring is updated. |
| **33. Search in Rotated Sorted Array** <br> Given a rotated sorted array, search for a target value. If found, return its index. | The solution uses binary search to efficiently locate the target by adjusting the search range based on the rotation index. |
| **34. Find First and Last Position of Element in Sorted Array** <br> Given a sorted array, find the first and last position of a given target value. | The solution uses binary search to find the leftmost and rightmost occurrences of the target. |
| **35. Search Insert Position** <br> Given a sorted array and a target value, return the index where the target should be inserted. | The solution uses binary search to find the correct index for inserting the target while maintaining the sorted order. |
| **36. Valid Sudoku** <br> Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the Sudoku rules. | The solution checks the rows, columns, and 3x3 subgrids to ensure that the numbers from 1-9 appear only once in each. |
| **37. Sudoku Solver** <br> Write a program to solve a Sudoku puzzle by filling the empty cells. | The solution uses backtracking to try filling cells with possible numbers and backtracks when an invalid configuration is found. |
| **38. Count and Say** <br> The `n`-th term of the sequence is generated by reading the digits of the previous term. | The solution generates each term in the sequence by counting consecutive digits and forming the next term. |
| **39. Combination Sum** <br> Given a set of candidate numbers (without duplicates) and a target number, find all unique combinations of numbers that sum up to the target. | The solution uses a backtracking approach to generate all possible combinations and ensures uniqueness by checking combinations at each recursive call. |
| **40. Combination Sum II** <br> Same as Combination Sum but with repeated numbers allowed. | The solution uses backtracking and ensures uniqueness by skipping repeated elements during the recursion. |
| **41. First Missing Positive** <br> Given an unsorted integer array, find the smallest missing positive integer. | The solution uses the array itself to mark elements that have been seen, rearranging elements to place each integer at its correct index. |
| **42. Trapping Rain Water** <br> Given an array of non-negative integers representing the elevation map, compute how much water it can trap after raining. | The solution uses two pointers to calculate the water trapped by comparing the maximum heights to the left and right of each position. |
| **43. Multiply Strings** <br> Multiply two numbers represented as strings. | The solution performs multiplication digit by digit, accounting for carries, and combines the results to form the final string representation. |
| **44. Wildcard Matching** <br> Implement wildcard matching with support for `?` and `*`. | The solution uses dynamic programming to match the string against the pattern, where `?` matches any single character and `*` matches zero or more characters. |
| **45. Jump Game II** <br> Given an array of non-negative integers, find the minimum number of jumps to reach the last index. | The solution uses a greedy approach to track the farthest index that can be reached with each jump and ensures the minimum number of jumps. |
| **46. Permutations** <br> Given a collection of distinct integers, return all possible permutations. | The solution uses backtracking to generate all permutations of the given list of integers. |
| **47. Permutations II** <br> Same as Permutations but with duplicate numbers. | The solution uses backtracking and ensures uniqueness by skipping over repeated elements during recursion. |
| **48. Rotate Image** <br> You are given an `n x n` 2D matrix, rotate it 90 degrees clockwise. | The solution involves transposing the matrix and then reversing each row to achieve a 90-degree clockwise rotation. |
| **49. Group Anagrams** <br> Given a list of strings, group the anagrams together. | The solution uses a hash map where the key is a sorted string, and the value is a list of strings that are anagrams. |
| **50. Pow(x, n)** <br> Implement `pow(x, n)`, which calculates `x` raised to the power of `n`. | The solution uses divide-and-conquer to efficiently calculate the power by reducing the problem size logarithmically. |
| **51. N-Queens** <br> The n-queens puzzle is the problem of placing n queens on an n×n chessboard so that no two queens threaten each other. | The solution uses backtracking to try placing queens row by row and ensures that no queens threaten each other by checking columns and diagonals. |
| **52. N-Queens II** <br> Same as N-Queens but return the total number of distinct solutions. | The solution uses backtracking to count the distinct solutions. |
| **53. Maximum Subarray** <br> Given an integer array, find the contiguous subarray (containing at least one number) that has the largest sum. | The solution uses Kadane’s algorithm to iterate through the array, calculating the maximum sum of subarrays. |
| **54. Spiral Matrix** <br> Given an `m x n` matrix, return all elements of the matrix in spiral order. | The solution simulates the spiral traversal by adjusting the boundaries of the matrix after traversing each layer. |
| **55. Jump Game** <br> Given an array of non-negative integers, determine if you can reach the last index. | The solution uses a greedy approach to track the farthest index that can be reached at each step. |
| **56. Merge Intervals** <br> Given a collection of intervals, merge all overlapping intervals. | The solution first sorts the intervals by their start time and then iterates through the sorted intervals, merging overlapping ones. |
| **57. Insert Interval** <br> Insert a new interval into a collection of non-overlapping intervals, and merge if necessary. | The solution first inserts the new interval and then merges any overlapping intervals. |
| **58. Length of Last Word** <br> Given a string, return the length of the last word. | The solution trims the string and splits it into words, returning the length of the last word. |
| **59. Spiral Matrix II** <br> Given a positive integer `n`, generate an `n x n` matrix filled with elements from 1 to n² in spiral order. | The solution follows the same approach as spiral matrix traversal, filling the matrix with values in a spiral order. |
| **60. Permutation Sequence** <br> Find the `k`-th permutation sequence of numbers from 1 to `n`. | The solution calculates the factorial of each number to determine the correct permutation based on the position `k`. |
| **61. Rotate List** <br> Given a linked list, rotate the list to the right by k places. | The solution calculates the length of the list and adjusts the head pointer after rotating by `k` steps. |
| **62. Unique Paths** <br> A robot is located at the top-left corner of a `m x n` grid. It can only move down or right. How many unique paths are there? | The solution uses dynamic programming to calculate the number of ways to reach each point in the grid. |
| **63. Unique Paths II** <br> Same as Unique Paths but some of the cells are blocked. | The solution uses dynamic programming, ensuring that blocked cells are treated as obstacles. |
| **64. Minimum Path Sum** <br> Given a `m x n` grid filled with non-negative numbers, find a path from the top left to the bottom right which minimizes the sum of the numbers along the path. | The solution uses dynamic programming to calculate the minimum path sum at each point. |
| **65. Valid Number** <br> Determine if a string represents a valid number. | The solution uses a finite state machine (FSM) to determine if the input string matches the patterns for a valid number. |
| **66. Plus One** <br> Given a non-empty array of digits representing a non-negative integer, increment the integer by one. | The solution iterates from right to left, adding one to the digits, handling the carry if necessary. |
| **67. Add Binary** <br> Given two binary strings, return their sum (also a binary string). | The solution simulates binary addition by iterating over the strings, adding corresponding bits and managing the carry. |
| **68. Text Justification** <br> Given a list of words and a length `maxWidth`, format the text such that each line has exactly `maxWidth` characters and is fully justified. | The solution splits the text into lines, and then spaces are added between words to ensure the line is fully justified. |
# LeetCode Problems and Explanations (69-110)

| **Problem Statement** | **Explanation** |
|-----------------------|-----------------|
| **69. Sqrt(x)** <br> Implement `int sqrt(int x)`, which calculates and returns the square root of `x`. | The solution uses binary search to find the integer square root. The search space is limited to `0` to `x`, and we keep narrowing it down until we find the closest integer value. |
| **70. Climbing Stairs** <br> You are climbing a staircase. It takes `n` steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? | This problem can be solved using dynamic programming, where the number of ways to reach each step is the sum of the ways to reach the previous step and the step before that. |
| **71. Simplify Path** <br> Given an absolute path for a file (Unix-style), simplify it. | The solution uses a stack to process each part of the path. Each `..` moves one step back, and each `/` represents a directory separation. |
| **72. Edit Distance** <br> Given two strings `word1` and `word2`, return the minimum number of operations required to convert `word1` to `word2`. | This problem can be solved using dynamic programming. The states represent the minimum number of operations to convert substrings of the two words. |
| **73. Set Matrix Zeroes** <br> Given an `m x n` matrix, if an element is 0, set its entire row and column to 0. | The solution uses two sets to track the rows and columns that need to be zeroed. After marking, it updates the matrix in place. |
| **74. Search a 2D Matrix** <br> Write an efficient algorithm that searches for a value in an `m x n` matrix. | The solution treats the matrix as a sorted 1D array and uses binary search to locate the value. |
| **75. Sort Colors** <br> Given an array with values `0`, `1`, and `2`, sort the array in-place without using the `sort()` function. | The solution uses the Dutch National Flag algorithm with three pointers to partition the array into three sections. |
| **76. Minimum Window Substring** <br> Given two strings `s` and `t`, return the minimum window substring of `s` that contains all the characters of `t`. | The solution uses the sliding window technique to dynamically adjust the window size and track the characters that need to be included. |
| **77. Combinations** <br> Given two integers `n` and `k`, return all possible combinations of `k` numbers out of `1..n`. | This can be solved using backtracking, where we select each number and recurse to fill the combination. |
| **78. Subsets** <br> Given an integer array `nums`, return all possible subsets. | The solution uses a backtracking approach to generate all subsets, either including or excluding each element. |
| **79. Word Search** <br> Given a `m x n` board and a word, find if the word exists in the grid. | The solution uses backtracking to explore all possible directions and tries to match the word by recursively exploring the adjacent cells. |
| **80. Remove Duplicates from Sorted Array II** <br> Given a sorted array, remove duplicates such that each element appears at most twice and return the new length. | The solution uses a two-pointer technique to keep track of the last valid element and ensures that no element appears more than twice. |
| **81. Search in Rotated Sorted Array II** <br> Given a rotated sorted array, find if a target value exists in the array. | This problem can be solved using binary search with additional handling for duplicates that can cause ambiguity in the mid-point value. |
| **82. Remove Duplicates from Sorted List II** <br> Given a sorted linked list, remove all elements that have duplicates, leaving only distinct numbers. | The solution uses a two-pointer technique to identify nodes with duplicates and skip them. |
| **83. Remove Duplicates from Sorted List** <br> Given a sorted linked list, delete all duplicates such that each element appears only once. | The solution iterates through the list, removing nodes with the same value as the next node. |
| **84. Largest Rectangle in Histogram** <br> Given an array of integers representing the heights of bars in a histogram, find the area of the largest rectangle that can be formed. | The solution uses a stack to keep track of the indices of the bars and calculates the area whenever the stack is updated. |
| **85. Maximal Rectangle** <br> Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area. | The solution treats each row as the base of a histogram and uses the largest rectangle in histogram algorithm to calculate the area. |
| **86. Partition List** <br> Given a linked list and a value `x`, partition the list so that all nodes less than `x` come before nodes greater than or equal to `x`. | The solution uses two separate lists: one for values less than `x` and one for values greater than or equal to `x`. |
| **87. Scramble String** <br> Given two strings `s1` and `s2`, determine if `s2` is a scrambled string of `s1`. | The solution uses dynamic programming to recursively check if `s2` can be obtained by scrambling `s1` at each step. |
| **88. Merge Sorted Array** <br> Given two sorted arrays, merge them into a single sorted array. | The solution uses a two-pointer technique to merge the arrays starting from the end, avoiding overwriting elements. |
| **89. Gray Code** <br> Generate a sequence of `n` Gray code numbers. | The solution generates Gray code by using the bitwise XOR operation between consecutive numbers. |
| **90. Subsets II** <br> Given an integer array, return all possible subsets, including duplicates. | The solution uses backtracking and ensures that duplicates are avoided by sorting the array and skipping over repeated elements. |
| **91. Decode Ways** <br> Given a string containing digits, determine the total number of ways to decode it. | The solution uses dynamic programming to keep track of the number of ways to decode the string at each position. |
| **92. Reverse Linked List II** <br> Reverse a sublist of a linked list between positions `m` and `n`. | The solution involves reversing the sublist while connecting the rest of the list around it. |
| **93. Restore IP Addresses** <br> Given a string, restore it by returning all possible valid IP address combinations. | The solution uses backtracking to split the string into 4 parts, ensuring each part is valid. |
| **94. Binary Tree Inorder Traversal** <br> Given the root of a binary tree, return the inorder traversal of its nodes' values. | The solution uses recursion to traverse the left subtree, visit the root, and then traverse the right subtree. |
| **95. Unique Binary Search Trees II** <br> Given an integer `n`, generate all structurally unique BST's (binary search trees) that store values 1 to `n`. | The solution uses recursion and dynamic programming to generate all possible BSTs by considering each number as the root. |
| **96. Unique Binary Search Trees** <br> Given an integer `n`, return the number of structurally unique BST's (binary search trees) that store values 1 to `n`. | The solution uses dynamic programming, where each subtree count is computed by combining the results from smaller subproblems. |
| **97. Interleaving String** <br> Given strings `s1`, `s2`, and `s3`, check if `s3` is formed by interleaving `s1` and `s2`. | The solution uses dynamic programming to check if the characters of `s3` can be obtained by interleaving `s1` and `s2` in order. |
| **98. Validate Binary Search Tree** <br> Given the root of a binary tree, determine if it is a valid binary search tree. | The solution recursively checks that for each node, the left child is less than the node and the right child is greater, ensuring BST properties hold. |
| **99. Recover Binary Search Tree** <br> Two elements of a binary search tree are swapped by mistake. Recover the tree without changing its structure. | The solution uses an inorder traversal to find the swapped nodes and then swaps them back to restore the tree. |
| **100. Same Tree** <br> Given the roots of two binary trees, determine if they are the same or not. | The solution recursively compares the nodes of the two trees, ensuring the structures and values are identical. |
| **101. Symmetric Tree** <br> Given the root of a binary tree, check whether it is a mirror of itself (symmetric around its center). | The solution uses recursion to compare the left and right subtrees, ensuring symmetry at each level. |
| **102. Binary Tree Level Order Traversal** <br> Given a binary tree, return the level order traversal of its nodes' values. | The solution uses a queue to perform a breadth-first search and capture the nodes at each level of the tree. |
| **103. Binary Tree Zigzag Level Order Traversal** <br> Given a binary tree, return the zigzag level order traversal of its nodes' values. | The solution uses breadth-first search and alternates the direction of traversal at each level to achieve the zigzag order. |
| **104. Maximum Depth of Binary Tree** <br> Given the root of a binary tree, return its maximum depth. | The solution uses recursion to compute the depth of each subtree and returns the maximum of the left and right subtree depths. |
| **105. Construct Binary Tree from Preorder and Inorder Traversal** <br> Given preorder and inorder traversal of a tree, construct the binary tree. | The solution recursively constructs the tree by using the preorder traversal to determine the root and the inorder traversal to determine the left and right subtrees. |
| **106. Construct Binary Tree from Inorder and Postorder Traversal** <br> Given inorder and postorder traversal of a tree, construct the binary tree. | Similar to the previous problem, but the postorder traversal is used to determine the root and recursively build the tree. |
| **107. Binary Tree Level Order Traversal II** <br> Given a binary tree, return the level order traversal of its nodes' values from bottom to top. | The solution performs level order traversal and stores each level in a list, which is then reversed before returning. |
| **108. Convert Sorted Array to Binary Search Tree** <br> Given a sorted array, convert it into a height-balanced binary search tree. | The solution recursively picks the middle element of the array to ensure the tree is balanced. |
| **109. Convert Sorted List to Binary Search Tree** <br> Given a singly linked list where elements are sorted in ascending order, convert it into a height-balanced binary search tree. | The solution uses a slow and fast pointer technique to find the middle element of the list and recursively builds the tree. |
| **110. Balanced Binary Tree** <br> Given a binary tree, determine if it is balanced. | The solution uses recursion to compute the height of each subtree while checking if the tree is balanced at each step. |
