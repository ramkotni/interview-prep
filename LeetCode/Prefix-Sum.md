| **Problem**                             | **Explanation**                                                                                                                                                                                                 | **Solution (Java)**                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|-----------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Range Sum Query - Immutable (LeetCode #303)** | Given an immutable array, you need to implement a method that can efficiently compute the sum of elements between indices `i` and `j` for multiple queries. **Prefix Sum** is used to precompute cumulative sums, allowing for fast range queries. | **Prefix Sum Approach**: Preprocess the array to create a prefix sum array. The sum of elements from index `i` to `j` can be calculated as `prefix[j] - prefix[i-1]`. | ```java<br>class NumArray {<br>    private int[] prefix;<br>    public NumArray(int[] nums) {<br>        prefix = new int[nums.length + 1];<br>        for (int i = 0; i < nums.length; i++) {<br>            prefix[i + 1] = prefix[i] + nums[i];<br>        }<br>    }<br>    public int sumRange(int left, int right) {<br>        return prefix[right + 1] - prefix[left];<br>    }<br>}<br>```                                                                                                                                                          |
| **Contiguous Array (LeetCode #525)**   | Given a binary array, find the maximum length of a contiguous subarray with an equal number of 0's and 1's. This can be done by keeping track of a **cumulative sum** (increment for 1, decrement for 0) and using a **hash map** to store first occurrences of cumulative sums. | **Hash Map Approach**: Iterate over the array, maintain a cumulative sum. Use a hash map to store the first occurrence of each cumulative sum. If the sum repeats, it means the subarray between those indices has equal 0's and 1's. | ```java<br>class Solution {<br>    public int findMaxLength(int[] nums) {<br>        Map<Integer, Integer> map = new HashMap<>();<br>        map.put(0, -1);<br>        int maxLength = 0, sum = 0;<br>        for (int i = 0; i < nums.length; i++) {<br>            sum += nums[i] == 0 ? -1 : 1;<br>            if (map.containsKey(sum)) {<br>                maxLength = Math.max(maxLength, i - map.get(sum));<br>            } else {<br>                map.put(sum, i);<br>            }<br>        }<br>        return maxLength;<br>    }<br>}<br>```                                                                                                                                                                |
| **Subarray Sum Equals K (LeetCode #560)** | Given an array of integers, you need to find the total number of continuous subarrays whose sum equals `k`. This can be solved by using **prefix sum** with a **hash map** to store cumulative sums and find the number of subarrays with sum equal to `k`. | **Prefix Sum with Hash Map Approach**: As you iterate, calculate the cumulative sum. Use a hash map to track how many times `sum - k` has appeared. This tells you how many subarrays sum to `k`. | ```java<br>class Solution {<br>    public int subarraySum(int[] nums, int k) {<br>        Map<Integer, Integer> map = new HashMap<>();<br>        map.put(0, 1); // Base case for sum 0<br>        int count = 0, sum = 0;<br>        for (int num : nums) {<br>            sum += num;<br>            if (map.containsKey(sum - k)) {<br>                count += map.get(sum - k);<br>            }<br>            map.put(sum, map.getOrDefault(sum, 0) + 1);<br>        }<br>        return count;<br>    }<br>}<br>```                                                                                                                                                                                                                      |
| **Prefix Sum (LeetCode #304)**         | Given a 2D matrix, implement a method that allows you to query the sum of elements in a submatrix. You need to preprocess the matrix to allow for fast submatrix sum queries using **Prefix Sum**. | **Prefix Sum for 2D Matrix**: Preprocess the matrix to build a `prefixSum` array. For any submatrix defined by its corners, use the formula `prefixSum[i][j] - prefixSum[i-1][j] - prefixSum[i][j-1] + prefixSum[i-1][j-1]` to compute the sum in constant time. | ```java<br>class NumMatrix {<br>    private int[][] prefixSum;<br>    public NumMatrix(int[][] matrix) {<br>        if (matrix.length == 0 || matrix[0].length == 0) return;<br>        int m = matrix.length, n = matrix[0].length;<br>        prefixSum = new int[m + 1][n + 1];<br>        for (int i = 1; i <= m; i++) {<br>            for (int j = 1; j <= n; j++) {<br>                prefixSum[i][j] = matrix[i - 1][j - 1] + prefixSum[i - 1][j] + prefixSum[i][j - 1] - prefixSum[i - 1][j - 1];<br>            }<br>        }<br>    }<br>    public int sumRegion(int row1, int col1, int row2, int col2) {<br>        return prefixSum[row2 + 1][col2 + 1] - prefixSum[row1][col2 + 1] - prefixSum[row2 + 1][col1] + prefixSum[row1][col1];<br>    }<br>}<br>```                                                                                                                                                                                                                     |


Explanation:
Range Sum Query - Immutable (LeetCode #303):

Problem: Preprocess an immutable array so that range sum queries can be answered in constant time.
Solution: Use a prefix sum array to store cumulative sums. For each query, calculate the sum by subtracting the appropriate values from the prefix sum array.
Contiguous Array (LeetCode #525):

Problem: Find the maximum length of a contiguous subarray with an equal number of 0s and 1s.
Solution: Maintain a cumulative sum where 1 adds +1 and 0 subtracts -1. Use a hash map to track the first occurrence of each cumulative sum. When the sum repeats, the subarray between those indices has equal 0s and 1s.
Subarray Sum Equals K (LeetCode #560):

Problem: Count how many subarrays have a sum equal to k.
Solution: Use prefix sums and a hash map to count how many times the sum current_sum - k has appeared before. This allows you to count how many subarrays sum to k.
Prefix Sum (LeetCode #304):

Problem: Given a 2D matrix, efficiently compute the sum of elements in a submatrix defined by any four coordinates (row1, col1) to (row2, col2).
Solution: Use a 2D prefix sum array. The sum of any submatrix can be calculated in constant time using the inclusion-exclusion principle on the prefixSum matrix.
Time Complexity:
Range Sum Query - Immutable (LeetCode #303): Preprocessing is O(n), and each query is O(1).
Contiguous Array (LeetCode #525): Time complexity is O(n).
Subarray Sum Equals K (LeetCode #560): Time complexity is O(n).
Prefix Sum (LeetCode #304): Preprocessing the matrix is O(m * n), and each query is O(1).
These problems highlight the usefulness of the Prefix Sum approach in solving range sum queries efficiently, whether in 1D or 2D arrays.
