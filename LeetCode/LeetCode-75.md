| **Video Link**                           | **Category**  | **Problem**                                              | **Explanation**                                                                                  |
|------------------------------------------|---------------|----------------------------------------------------------|--------------------------------------------------------------------------------------------------|
| [Two Sum](https://youtu.be/KLlXCFG5TnA)   | Arrays        | [Two Sum](https://leetcode.com/problems/two-sum/)          | Use a hash map to instantly check for the difference value. Map will store the index of the last occurrence of a number. Don't use the same element twice.  |
| [Best Time to Buy and Sell Stock](https://youtu.be/1pkOgXD63yU) | Arrays        | [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/) | Find local min and search for local max using a sliding window. |
| [Contains Duplicate](https://youtu.be/3OamzN90kPg) | Arrays        | [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/) | Use a hash set to get unique values in the array and check for duplicates easily. |
| [Product of Array Except Self](https://youtu.be/bNvIQI2wAjk) | Arrays        | [Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/) | Make two passes, first in-order and second in-reverse to compute the products. |
| [Maximum Subarray](https://youtu.be/5WZl3MMT0Eg) | Arrays        | [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/) | Dynamic programming: compute the maximum sum for each prefix. |
| [Maximum Product Subarray](https://youtu.be/lXVy6YWFcRM) | Arrays        | [Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/) | Dynamic programming: compute max and max-abs-value for each prefix subarray. |
| [Find Minimum in Rotated Sorted Array](https://youtu.be/nIVW4P8b1VA) | Arrays        | [Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/) | Check if half of the array is sorted to find the pivot. The array is guaranteed to be in at most two sorted subarrays. |
| [Search in Rotated Sorted Array](https://youtu.be/U8XENwh8Oy8) | Arrays        | [Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/) | At most two sorted halves. Mid will be part of left sorted or right sorted. If the target is in the range of the sorted portion, search it; otherwise, search the other half. |
| [3Sum](https://youtu.be/jzZsG8n2R9A)     | Arrays        | [3Sum](https://leetcode.com/problems/3sum/)               | Sort input, for each first element, find next two where -a = b+c. Skip duplicates using two pointers. |
| [Container With Most Water](https://youtu.be/UuiTKBwPgAo) | Arrays        | [Container With Most Water](https://leetcode.com/problems/container-with-most-water/) | Shrinking window: left and right pointers initially at endpoints. Shift the pointer with the minimum height. |
| [Sum of Two Integers](https://youtu.be/gVUrDV4tZfY) | Binary        | [Sum of Two Integers](https://leetcode.com/problems/sum-of-two-integers/) | Add bit by bit, be mindful of carry. After adding, if carry is still 1, then add it as well. |
| [Number of 1 Bits](https://youtu.be/5Km3utixwZs) | Binary        | [Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/) | Use bit shifting instead of dividing. To get the 1's place, use bitwise AND. |
| [Counting Bits](https://youtu.be/RyBM56RIWrM) | Binary        | [Counting Bits](https://leetcode.com/problems/counting-bits/) | Observe the pattern for numbers. `res[i] = res[i - offset]`, where offset is the largest power of 2 <= i. |
| [Missing Number](https://youtu.be/WnPLSRLSANE) | Binary        | [Missing Number](https://leetcode.com/problems/missing-number/) | Compute expected sum - real sum. Alternatively, XOR `n` with each index and value. |
| [Reverse Bits](https://youtu.be/UcoN6UjAI64) | Binary        | [Reverse Bits](https://leetcode.com/problems/reverse-bits/) | Reverse each of the 32 bits. |
| [Climbing Stairs](https://youtu.be/Y0lT9Fck7qI) | Dynamic Programming | [Climbing Stairs](https://leetcode.com/problems/climbing-stairs/) | Subproblem: find (n-1) and (n-2), sum = n. |
| [Coin Change](https://youtu.be/H9bfqozjoqs) | Dynamic Programming | [Coin Change](https://leetcode.com/problems/coin-change/) | Top-down: recursive DFS, for each amount, branch for each coin and cache results. Bottom-up: compute coins for each amount up to n using each coin. |
| [Longest Increasing Subsequence](https://youtu.be/cjWnW0hdF1Y) | Dynamic Programming | [Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/) | Recursive: for each num, get subsequence with and without the num. DP: subsequence length must end with each num, and the current num must be after a previous dp or by itself. |
| [Longest Common Subsequence](https://youtu.be/Ua0GhsJSlWM) | Dynamic Programming | [Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/) | Recursive: if first chars are equal, find LCS of remaining substrings. Cache results with nested loops. |
| [Word Break Problem](https://youtu.be/Sx9NNgInc3A) | Dynamic Programming | [Word Break Problem](https://leetcode.com/problems/word-break/) | For each prefix, if it is in the dictionary and `wordbreak(remaining string) = True`, return `True`. Cache results. |
| [Combination Sum](https://youtu.be/GBKI9VSKdGg) | Dynamic Programming | [Combination Sum](https://leetcode.com/problems/combination-sum/) | Visualize the decision tree. Base case: `curSum = target`. Each candidate can have children of itself or elements to the right to eliminate duplicates. |
| [House Robber](https://youtu.be/73r3KWiEvyk) | Dynamic Programming | [House Robber](https://leetcode.com/problems/house-robber/) | For each num, calculate the max of the previous subarray, or the num plus the previous subarray excluding the last element. |
| [House Robber II](https://youtu.be/rWAJCfYYOvM) | Dynamic Programming | [House Robber II](https://leetcode.com/problems/house-robber-ii/) | Subarray = array without the first and last element. Calculate the max for the subarray and decide whether to include the first or last element. |
| [Decode Ways](https://youtu.be/6aEyTjOwlJU) | Dynamic Programming | [Decode Ways](https://leetcode.com/problems/decode-ways/) | Check if the current character can be decoded in one or two ways. Use recursion with caching and an iterative DP solution. |
| [Unique Paths](https://youtu.be/IlEsdxuD4lY) | Dynamic Programming | [Unique Paths](https://leetcode.com/problems/unique-paths/) | Work backwards from the solution. Store paths for each position in the grid. Optimize by only storing the previous row. |
| [Jump Game](https://youtu.be/Yan0cv2cLy8) | Dynamic Programming | [Jump Game](https://leetcode.com/problems/jump-game/) | Visualize the recursive tree. Cache the solution for O(n) time/memory complexity. Iterate backwards to see if an element can reach the goal node. |
| [Clone Graph](https://youtu.be/mQeF6bN8hMk) | Graph         | [Clone Graph](https://leetcode.com/problems/clone-graph/) | Use recursive DFS and a hash map for visited nodes. |
| [Course Schedule](https://youtu.be/EgI5nU9etnU) | Graph         | [Course Schedule](https://leetcode.com/problems/course-schedule/) | Build an adjacency list with edges. Run DFS on each vertex. If a cycle is detected, there is a loop. |
| [Pacific Atlantic Water Flow](https://youtu.be/s-VkcjHqkGI) | Graph         | [Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/) | DFS on each cell, track visited cells and which can reach Pacific and Atlantic. Find overlap of cells that can reach both. |
| [Number of Islands](https://youtu.be/pV2kpPD66nE) | Graph         | [Number of Islands](https://leetcode.com/problems/number-of-islands/) | For each cell, if it is `1` and unvisited, run DFS and increment the count of islands. |
| [Longest Consecutive Sequence](https://youtu.be/P6RZZMu_maU) | Graph         | [Longest Consecutive Sequence](https://leetcode.com/problems/longest-consecutive-sequence/) | Use a brute force approach and try to optimize by considering the max subsequence containing each number. Add each number to a hash set and use it for checking consecutive elements. |
| [Alien Dictionary (Leetcode Premium)](https://youtu.be/6kTZYvNNyps) | Graph         | [Alien Dictionary](https://leetcode.com/problems/alien-dictionary/) | Find the adjacency list of unique characters and use topological sorting with loop detection. |
| [Graph Valid Tree (Leetcode Premium)](https://youtu.be/bXsUuownnoQ) | Graph         | [Graph Valid Tree](https://leetcode.com/problems/graph-valid-tree/) | Use union-find to detect cycles. If union is found, return `false`. Check if the tree is connected. |
| [Number of Connected Components in an Undirected Graph](https://youtu.be/_VnP-pF9GLw) | Graph         | [Number of Connected Components](https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/) | Run DFS/BFS starting from each unvisited node and increment the counter for each component found. |
| [Dijkstraâ€™s Algorithm](https://youtu.be/zUE-t3GwbKo) | Graph         | [Dijkstra's Algorithm](https://leetcode.com/problems/network-delay-time/) | Use a priority queue (min-heap) to get the next node with the smallest distance. |
| [Top K Frequent Elements](https://youtu.be/YPTqKIgVk-k) | Heap          | [Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/) | Use a **min-heap** that is kept at a size of `k`. If the size exceeds `k`, pop the minimum element. After processing all elements, the heap will contain the `k` most frequent elements. |
| [Merge K Sorted Lists](https://youtu.be/q5a5OiGbT6Q) | Heap          | [Merge K Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/) | We always want the minimum element from the current frontier. We can use a **min-heap** of size `k` to efficiently pop and push the minimum element. This is a divide-and-conquer approach for merging the lists. |
| [Find Median from Data Stream](https://youtu.be/itmhHWaHupI) | Heap          | [Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/) | Maintain the current median by using two heaps: a **max-heap** to store elements less than or equal to the median, and a **min-heap** to store elements greater than the median. After each insertion, update the median based on the number of elements in each heap. |
| [Reverse Linked List](https://youtu.be/T-wXxgtrBhs) | Linked List   | [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/) | Use two pointers to reverse the linked list. One pointer tracks the current node, the other tracks the previous node. |
| [Merge Two Sorted Lists](https://youtu.be/1QDO4jo_qTY) | Linked List   | [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/) | Merge two sorted linked lists using two pointers, one for each list. Compare values and build the new merged list. |
| [Detect Cycle in a Linked List](https://youtu.be/f6M2Wctb8PY) | Linked List   | [Detect Cycle in a Linked List](https://leetcode.com/problems/linked-list-cycle/) | Use two pointers. One moves slow (1 step), the other fast (2 steps). If they meet, there is a cycle. |
| [Flatten a Linked List](https://youtu.be/sJe88AlJFWY) | Linked List   | [Flatten a Linked List](https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/) | Use DFS or iterative approach to flatten the multi-level linked list. Maintain the correct pointers. |
| [Spiral Matrix](https://youtu.be/JwGtIW1q1Vs) | Matrix        | [Spiral Matrix](https://leetcode.com/problems/spiral-matrix/) | Track the boundaries (top, bottom, left, right) and move inward, collecting elements in spiral order. |
| [Set Matrix Zeroes](https://youtu.be/nOGZ04KReak) | Matrix        | [Set Matrix Zeroes](https://leetcode.com/problems/set-matrix-zeroes/) | Use first row and column to store which rows and columns need to be zeroed. |
| [Rotate Image](https://youtu.be/Lo5RvlcaLPg) | Matrix        | [Rotate Image](https://leetcode.com/problems/rotate-image/) | Transpose the matrix and reverse each row to achieve a 90-degree rotation. |
| [Search a 2D Matrix](https://youtu.be/J93tRrrFv2o) | Matrix        | [Search a 2D Matrix](https://leetcode.com/problems/search-a-2d-matrix/) | Treat the 2D matrix as a sorted 1D array. Use binary search for efficient search. |
| [Invert Binary Tree](https://youtu.be/8tMOMzO9Ok0) | Tree          | [Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/) | Swap the left and right children for every node recursively. |
| [Binary Tree Level Order Traversal](https://youtu.be/XH5dKvbEKzA) | Tree          | [Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/) | Use a queue for BFS to traverse the tree level by level. |
| [Max Depth of Binary Tree](https://youtu.be/JsL6bD0KOFw) | Tree          | [Max Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/) | Use DFS or BFS to traverse the tree, tracking the depth of each node. |
| [Balanced Binary Tree](https://youtu.be/U0uFzG5mHdQ) | Tree          | [Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/) | Check if the height difference between left and right subtrees is at most 1 for all nodes. |
| [Path Sum](https://youtu.be/hHESXVOb3Mc) | Tree          | [Path Sum](https://leetcode.com/problems/path-sum/) | Use DFS to find a path with a given sum, subtracting the current node's value from the target sum. |
| [Longest Substring Without Repeating Characters](https://youtu.be/3I2Q4zP6Jl0) | String        | [Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/) | Use a sliding window approach to expand the window and contract it when a duplicate character is found. |
| [Valid Anagram](https://youtu.be/ykNYHhOrmnw) | String        | [Valid Anagram](https://leetcode.com/problems/valid-anagram/) | Count characters in both strings and compare counts to determine if they are anagrams. |
| [Palindrome Permutation](https://youtu.be/pKf_RabQ8gI) | String        | [Palindrome Permutation](https://leetcode.com/problems/palindrome-permutation/) | A string can be rearranged into a palindrome if and only if at most one character has an odd count. |
| [String Compression](https://youtu.be/o7CUZ6tXtn4) | String        | [String Compression](https://leetcode.com/problems/string-compression/) | Use two pointers to compress the string by counting consecutive characters. |
| [Interval Intersection](https://youtu.be/SlACmf7M6dY) | Interval      | [Interval Intersection](https://leetcode.com/problems/interval-intersection/) | Merge the intervals: find the intersection and add it to the result. |
| [Merge Intervals](https://youtu.be/Fb-vnbo8dF4) | Interval      | [Merge Intervals](https://leetcode.com/problems/merge-intervals/) | Sort intervals by start time. Merge overlapping intervals. |
| [Insert Interval](https://youtu.be/Cw_jRAdWg3o) | Interval      | [Insert Interval](https://leetcode.com/problems/insert-interval
