I bro, drag it till the
Yeah. Now you can do that. You
I like to communicate between the micro services. Actually, typically, we are having a customer service and we are making the changes to the customer, and we are broadcasting the changes to the customer to all the downstream applications using the Kafka topic, actually. So that is how, like, we are able to play around with the kaska
like We are having a 10 topics. Actually, I
like we have multiple consumers, actually, I
No, actually we are having a topic. Each topic is having its own consumer groups. So like, assume that we have a customer topic is there so that is being subscribed by The like seven to eight Consumer groups, actually, so I
uh, sorry, sorry.
So it is nothing, but like when we have a collection, we would be opening up a stream, and we would be having the different functions would be there, like map function, filter function, so this is called the stream pipelining.
Intermediate means which would be resulting in a stream as output. Terminal would be like a non stream as output, and there would be many intermediate operations, but there will be only one terminal operation. So
like functional programming, lambda expression, stream, API, optional class, Java, date, time, API, so these are the different features.
Do to prevent the null pointer exception and to better manage the like presence of a value and absence of a value. That's where we would be used optional in nature. So
uh, typically, right? We would be doing a profiling for a large scale applications, and we would be checking like how the memory is behaving like with the different loads. And we would be using the like asynchronous programming and putting the records into the event loop kind of thing, so that, like, the load on the processing system would be somewhat moderately low,
not really
we would be use the chunk based processing. So the chunk based processing is like we would be picking up a chunk of records and process it. So that is how we would be using the streaming API. So
uh, we have been using the like, what to say, uh, cacheable annotation, and we are able to use the cache headers actually. And that is how like we are enabling The caching with respect to the RESTful API. Ah,
uh like Redis, distributed cache I would be using,
like in memory cache, distributed cache. So these are the ones we are using. Eh cache is the in memory cache, and Redis is the distributed cache. So
in memory cache and distribute in memory cache,
we have been using the like concurrent collections, and we have been using the like functional programming. That is how we are ensuring The thread safety you
third set please.
We have been using the actuator endpoints, and we are having a health check endpoint is there, and we are having the different endpoints, like pro Matheus endpoint. We are using the monitoring platforms like pro Matthias and Grafana, and we have been using the Sagar API, and We have been using the distributed tracing as well.
So
we have been using the Docker images, and these Docker images we are deploying into the Kubernetes using the Like Jenkins based CICD pipelines so
we are using the Jenkins based CICD pipelines.
We are having a build stage, unit test stage, like we are having a security stage and the code quality gate stage, sonar cube integration, Artifactory integration,
So these are the major Things that we have you.
I, yes, I worked on the angler and react both. Actually, I'm pretty good with both of them. I
You, yes, I am having a decent experience with the Node js as well.
Hello, you.
No, not really, but I have a decent experience. It's an awkward case. I
uh, see, typically we would be using the load children attribute that would be helping us to, like, do the lazy loading actually, load children attribute using the routing actually, so that would be helping us to do the lazy Loading. I
We have been using the like authorization server, and we have been using the authorization header for all the outgoing calls using the HTTP interceptors. And we have been able to work with this one like so like using the routing stage, we are using the route cards. So that is how We have been doing. I
we have been using the local storage. So that is the part of
so that is how we are Maintaining the state. So
yes, I try to work with the Angular material, and I was able to play around with that actually. So definitely, I have a great experience with that. I
yeah, I know Bootstrap and other things actually definitely Have a great experience with that. I
Sorry, ar,
they are accessibility standards. So
like, if you are visually blind, or something like, where we would be managing through the tab access actually,
we would be giving the options to access the application. So
yeah, sorting based on a like, merging with smaller elements.
Okay, let me think about it. So I
so it would be using a divide and conquer method. So it would be dividing the array into smaller arrays, and then building the and sorting them. And it would be coming back with, again, the output one actually, can I go ahead?
Okay, go For a Java. Wait, I
Yeah, so it would be defining the base case, like, if the length is less than or equal to one, then we are returning the array itself,
less than one. There is no Need to start, right? So,
Capturing the length of the
capturing the length of the array, then I'm finding the mid of the element.
I because I want to start the left one and the right one. I
so I want to Start the left and right. I
It's order of n square
order of n, log N,
order of n, log n,
n, log n,
1970-01-01T00:11:18+00:00--



