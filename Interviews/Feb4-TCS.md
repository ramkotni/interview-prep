I Okay, Java eight futures, you are asking, right? Yeah, so in the Java eight futures, there are some changes, as did so there are like, lambda expression, stream, APIs, functional interface, deeper methods, base 64 ENCODE, decode, static methods and interfaces. Optional classes, collector classes for each method, parallel array streams.
Optional classes i
Okay, like map versus filter versus word, reduce, map, filter, reduce, array methods. So generally, the map is nothing but mapping the element like filter takes Asana predicates as arguments, so basically, you are validating your inputs collection against the condition where the map allows you To define the user existent function on the stream. So
yes, I verbs,
compare, comparable and comparator you are asking,
Okay,
okay, compatible, and future is nothing but compatible. Future is a better choice for the complex asynchronizes programming while future is better for a simple
asynchronizes operations.
Future use the blocking calls to retrieve the result while compatible future uses non blocking operations. Compatible future can change the multiple tasks together, while future cannot like compatible future has the methods to handle the task completion, while future does not do it. So
until the task completion. But while future does not
call back function, sir, I'm asking.
So compatible, future can manually completed while future cannot do it. So compatible,
compatible,
manual compilation,
compilation,
like, like manual compilation, I
I love the
otter Follow up
Okay, okay, fine.
So in Java, manual compilation is nothing, but typically refers the ability to explicitly complete a computation or a single completion of a task, rather than relying on automatic execution flow In this
no problem otter or display.
Okay, so I phone
disconnect, and this speaker won't see me. Zoom, local, connect, I know teleport.
Amanda, Monday, mute, teleport,
well, you
sorry,
but link, late diction. Link, you could copy Salem really sorry time is shaken. Available later otter, I join,
join Join Room.
Join join them.
So manual compilation in the thread scale typically refers to ability to explicitly complete compilation or single the compilation of the task, rather than relying on automatic execution flow. This is relevant to compatible future and the future task, which allow the developer to manually complete a task, so manual compilation, so in compatible future class, Java,
yes, I worked on reactive programming.
Okay, reactive programming in the Java is nothing but a it is asynchronizes programming, which the data streams and the propagations of the changes it This means it becomes a possible to express the static, dynamic data streams with easy
via programming languages. So
okay, streams is nothing but the flow of any data and propagations are nothing but any I
like streams are not like in Java. Java streams are nothing but sequence element supporting functional styling and propagation is context of a streams usually refers to how The data or exceptions flow through a stream pipeline. So
so the functional style is nothing but a like suppose, instead of using often a for loop condition, we are using of a streams. It makes very easy to you, and you can write the Lambda expressions where the single notation like taking of an arguments and giving of any expressions and implementing of any various methods like filter map and grouping by collecting, collector in the form of a list, all the Java eight makes the developer easy to work on that instead of writing of the large, lengthy programming that is A functional way of styling of in programming you
Okay, in Java, we can tell that thread local storages are nothing but a memory management method that use the static or a global memory locals to the thread that allows the storage of the data that appears To be global in the system with separate threads. I
down the independent ya
rab even these.