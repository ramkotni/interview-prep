Interview Process: 

Prescreening Test – 12 MCQs will be sent to the candidate.
1st Round- MS Teams – 1 round hour coding test - Java, C#, Python
2nd Round – MS Team – 1 hour of system /API designing.
3rd Round – MS Team – 1 hour of round with the Manager.
 

 

Who we are Solutions Architecture team, focusing on delivering robust, scalable, and maintainable software solutions with a heavy emphasis on coding and technical leadership. In this role, you will be responsible for designing and implementing full-stack applications, APIs, containerized services, and leveraging AWS services, with a key focus on driving reusable software components, and building platforms. You will collaborate closely with product stakeholders, architects, and engineering teams to transform high-level architectural requirements into actionable, technical solutions.

 

This role is ideal for an experienced full-stack developer with strong modern cloud native distribution application development, AWS expertise, and a desire to lead by example through hands-on coding, technical mentorship, and independent problem-solving.

 

What we’re looking for

Hands-on Development: Lead the design, development, and deployment of full-stack applications with a strong focus on event driven microservices using cloud-native technologies. 

 

Coding and Architecture: Implement simple, readable, well designed software components, adhering to best coding practices in one or more languages. 

Framework & platform development: Implement reusable and scalable software framework and platforms. Own the development process from high-level requirements to post deployment activities. Build documentation for reusable components/platforms  

Containerization and Cloud Deployment: Drive the use of container technologies and orchestrate services on AWS infrastructure, ensuring scalability, reliability, and performance.

 

Collaboration: Partner with solutions architects, product owners, and domain experts to turn high-level business needs into detailed, actionable technical specifications and implementation plans.

Troubleshooting and Debugging: Independently troubleshoot, debug, and optimize code to ensure high availability and performance. Investigate and resolve complex software issues, providing support to the operations team.

 

Documentation: Create and maintain high-quality technical documentation that supports the development process, including architecture decision records, design specs, system architecture diagrams, and reusable patterns.

Non-functional Requirements: Ensure that all developed software meets non-functional requirements such as security, scalability, maintainability, performance, and compliance with industry standards.

 

What you’ll be doing

10+ years of experience in software engineering, preferably with a software engineer background with a proven track record of consistently delivering high impact software products in a timely manner.
3+ years of experience as an application or Solutions architect delivering enterprise solutions at scale using modern cloud native technologies (AWS preferred).
Proven experience in hands-on coding with one or more languages: Java, JavaScript, Python, or C#. Expertise in developing and deploying applications using microservices architecture, container technologies (Docker, Kubernetes), and cloud platforms (AWS preferred). Track record of including automated testing throughout the life cycle.
Experience implementing reusable software components, and shared libraries for enterprise-wide use in one or more languages like Java, C#, JavaScript, and Python is a must.
Proven experience designing & architecting enterprise scale transactional systems following microservice, event driven architecture style.
Good understanding of InfoSec, and DevSecOps principles using AWS technologies is a must. Relevant certifications, such as AWS Solutions Architect Associate, are highly desirable.
 

AWS Expertise:

Good understanding of AWS services, including EKS, Lambda, S3, API Gateway, DynamoDB, and other cloud-native technologies. AWS certifications, such as AWS Solutions Architect Associate or Developer, are a strong plus.
Experience with Containers and CI/CD Pipelines: Proven ability to design, build, and manage containerized applications using Kubernetes (Amazon EKS). Familiarity with modern CI/CD pipelines and DevOps practices.
Independent Worker and Team Player: Ability to work independently to drive complex technical projects to completion, as well as collaboratively with cross-functional teams.
Excellent Communication Skills: Strong interpersonal and communication skills, able to convey complex technical concepts to both technical and non-technical stakeholders.
 

Requirements:

Qualifications/ What you bring (Must Haves) – Highlight Top 3-5 skills.
Strong software engineering background (10+ years) in full stack application development.
3+ years of solid experience as application architect, API Development.
Hands on coder in one or more languages like Java, C#, Python.
AWS skillset -1 to 2 years.
Bachelors required.


Steps for Interview Preparation:
Prescreening Test (12 MCQs)
Brush up on core concepts:


Programming languages: Java, C#, Python (syntax, OOP principles, data structures, algorithms).
Cloud basics: AWS services like Lambda, S3, DynamoDB, API Gateway.
Microservices: Event-driven architecture, containerization (Docker, Kubernetes).
DevOps: CI/CD pipelines, InfoSec, DevSecOps principles.
Practice online quizzes:


Use platforms like HackerRank, LeetCode, or AWS Skill Builder for MCQs on programming and AWS.
<hr></hr>
1st Round: Coding Test (1 Hour)
Focus on problem-solving:


Practice data structures and algorithms (arrays, strings, trees, graphs, dynamic programming).
Solve problems on platforms like LeetCode, Codeforces, or GeeksforGeeks.
Hands-on coding:


Write clean, modular, and well-documented code in Java, C#, or Python.
Practice implementing microservices and API endpoints.
Time management:


Solve problems within a time limit to simulate the test environment.
<hr></hr>
2nd Round: System/API Design (1 Hour)
Understand system design principles:


Study scalable architectures, event-driven microservices, and RESTful API design.
Learn about database design (SQL vs NoSQL), caching, and load balancing.
Prepare for AWS-specific design:


Understand AWS services like EKS, Lambda, API Gateway, DynamoDB, and S3.
Learn how to design containerized applications using Docker and Kubernetes.
Practice system design problems:


Use resources like "System Design Primer" or "Grokking the System Design Interview".
Practice designing systems like e-commerce platforms, messaging systems, or file storage services.
<hr></hr>
3rd Round: Managerial Round (1 Hour)
Prepare for behavioral questions:


Use the STAR method (Situation, Task, Action, Result) to answer questions about past experiences.
Highlight leadership, problem-solving, and collaboration skills.
Showcase technical leadership:


Discuss your experience in designing reusable components, mentoring teams, and delivering scalable solutions.
Understand the role:


Be ready to explain how your skills align with the job description, focusing on AWS expertise, microservices, and full-stack development.
<hr></hr>
General Preparation
AWS Expertise:


Study AWS services in-depth (EKS, Lambda, S3, DynamoDB, API Gateway).
Consider taking the AWS Solutions Architect Associate certification.
Hands-on with tools:


Practice using Docker, Kubernetes, and setting up CI/CD pipelines.
Documentation skills:


Learn to create architecture diagrams, design specs, and API documentation.
Mock interviews:


Practice coding and system design interviews with peers or on platforms like Pramp or Interviewing.io.
Review your projects:
Be ready to discuss your past work, focusing on scalable solutions, cloud deployments, and reusable components.

=====
calable Architectures
Scalable architectures are designed to handle increasing workloads efficiently without compromising performance. They ensure that a system can grow to accommodate more users, data, or requests.


Key Concepts:
Horizontal Scaling: Adding more servers or instances to distribute the load.
Example: Adding more EC2 instances in AWS.
Vertical Scaling: Increasing the resources (CPU, RAM) of a single server.
Example: Upgrading an RDS instance to a larger size.
Load Balancing: Distributing incoming traffic across multiple servers.
Example: Using AWS Elastic Load Balancer (ELB).
Caching: Storing frequently accessed data in memory to reduce database load.
Example: Using Redis or Memcached.
Database Sharding: Splitting a database into smaller, more manageable pieces.
Example: Partitioning user data by region.
Asynchronous Processing: Offloading tasks to background workers.
Example: Using message queues like RabbitMQ or AWS SQS.
<hr></hr>
Event-Driven Microservices
Event-driven microservices use events to communicate between services, enabling loose coupling and scalability.


Key Concepts:
Event Producers: Services that generate events.
Example: A user registration service emits a "UserRegistered" event.
Event Consumers: Services that listen for and process events.
Example: An email service listens for "UserRegistered" events to send welcome emails.
Event Brokers: Middleware that routes events between producers and consumers.
Example: Kafka, RabbitMQ, or AWS SNS/SQS.
Event Types:
Domain Events: Represent changes in the system (e.g., "OrderPlaced").
Integration Events: Used for communication between services.
Benefits:
Decoupled services.
Scalability and fault tolerance.
Real-time processing.
Example Flow:
A user places an order.
The "OrderPlaced" event is published to a message broker.
The inventory service consumes the event to update stock levels.
The notification service consumes the event to send a confirmation email.
<hr></hr>
RESTful API Design
REST (Representational State Transfer) is an architectural style for designing networked applications.
Key Principles:
Statelessness: Each request from a client contains all the information needed to process it.
Resource-Based: APIs expose resources (e.g., /users, /orders).
HTTP Methods:
GET: Retrieve data.
POST: Create a resource.
PUT: Update a resource.
DELETE: Remove a resource.
HTTP Status Codes:
200 OK: Success.
201 Created: Resource created.
404 Not Found: Resource not found.
500 Internal Server Error: Server error.
HATEOAS (Hypermedia as the Engine of Application State): Responses include links to related actions.
Versioning: Use versioning to manage API changes (e.g., /v1/users).
Example API Design:
Endpoint: /users
GET /users: Retrieve all users.
POST /users: Create a new user.
Endpoint: /users/{id}
GET /users/{id}: Retrieve a specific user.
PUT /users/{id}: Update a specific user.
DELETE /users/{id}: Delete a specific user.
<hr></hr>
Use Case Example: E-Commerce System
Scalable Architecture:
Use AWS Auto Scaling to handle traffic spikes during sales.
Cache product data using Redis to reduce database load.
Event-Driven Microservices:
"OrderPlaced" event triggers inventory and notification services.
"PaymentProcessed" event triggers order fulfillment.
RESTful API:
/products: Manage product catalog.
/orders: Place and track orders.
/users: Manage user accounts.



 
